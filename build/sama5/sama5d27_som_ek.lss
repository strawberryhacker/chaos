
/home/strawberry/chaos/build/sama5/sama5d27_som_ek.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .kernel_entry 000000fc  20000000  20000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0000141c  20000100  20000100  00010100  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  2000151c  2000151c  0001151c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  20001520  20001520  00011520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000234  20001524  20001524  00011524  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000438  20001758  20001758  00011758  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00063300  20001bc0  20001bc0  00011b90  2**6
                  ALLOC
  7 .stack        00000c00  20064ec0  20064ec0  00011b90  2**0
                  ALLOC
  8 .ARM.attributes 0000002d  00000000  00000000  00011b90  2**0
                  CONTENTS, READONLY
  9 .comment      000000a7  00000000  00000000  00011bbd  2**0
                  CONTENTS, READONLY
 10 .debug_line   00002bde  00000000  00000000  00011c64  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_info   0000778b  00000000  00000000  00014842  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 00001f90  00000000  00000000  0001bfcd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00000380  00000000  00000000  0001df60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00005bee  00000000  00000000  0001e2e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    000020bb  00000000  00000000  00023ece  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000390  00000000  00000000  00025f89  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00001570  00000000  00000000  00026319  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  00000578  00000000  00000000  0002788c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .kernel_entry:

20000000 <_kernel_s>:
.extern ddr_start

.section .kernel_entry, "ax", %progbits
kernel_entry:
    // In ARMv7-A the PC is pointing 8 bytes ahead in ARM mode
    sub r0, pc, #8    // This has to be the first instruction
20000000:	e24f0008 	sub	r0, pc, #8
    ldr r1, =ddr_start
20000004:	e59f10e0 	ldr	r1, [pc, #224]	; 200000ec <skip_reloc+0x10>

    cpsid afi
20000008:	f10c01c0 	cpsid	aif

    // Check if a relocation is needed
    cmp r0, r1
2000000c:	e1500001 	cmp	r0, r1
    bne reloc
20000010:	1a000000 	bne	20000018 <reloc>
    beq skip_reloc
20000014:	0a000030 	beq	200000dc <skip_reloc>

20000018 <reloc>:

reloc:
    ldr r2, =_kernel_size
20000018:	e59f20d0 	ldr	r2, [pc, #208]	; 200000f0 <skip_reloc+0x14>
    lsr r2, r2, #2
2000001c:	e1a02122 	lsr	r2, r2, #2
    add r2, r2, #1          // Kernel size in words
20000020:	e2822001 	add	r2, r2, #1

    // Relocate the kernel to the start of DDR memory
1:  ldr r3, [r0], #4
20000024:	e4903004 	ldr	r3, [r0], #4
    str r3, [r1], #4
20000028:	e4813004 	str	r3, [r1], #4
    subs r2, r2, #1
2000002c:	e2522001 	subs	r2, r2, #1
    bne 1b
20000030:	1afffffb 	bne	20000024 <reloc+0xc>

    // Check if the dcache is enabled
    mrc p15, 0, r0, c1, c0, 0
20000034:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst r0, #(1 << 2)
20000038:	e3100004 	tst	r0, #4
    beq skip_disable_dcache
2000003c:	0a00001b 	beq	200000b0 <skip_disable_dcache>

    // Get the cache size
    mrc p15, 1, r5, c0, c0, 0
20000040:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
    lsr r3, r5, #3
20000044:	e1a031a5 	lsr	r3, r5, #3
    mov r6, #0x3FF
20000048:	e30063ff 	movw	r6, #1023	; 0x3ff
    and r3, r3, r6
2000004c:	e0033006 	and	r3, r3, r6
    add r3, r3, #1                     // Number of ways
20000050:	e2833001 	add	r3, r3, #1

    mov r6, #0x7FFF
20000054:	e3076fff 	movw	r6, #32767	; 0x7fff
    lsr r4, r5, #13
20000058:	e1a046a5 	lsr	r4, r5, #13
    and r4, r4, r6
2000005c:	e0044006 	and	r4, r4, r6
    add r4, r4, #1                     // Number of sets
20000060:	e2844001 	add	r4, r4, #1

    // Disable and clean the dcache
    mov r0, #0                         // Way index
20000064:	e3a00000 	mov	r0, #0
1:  mov r1, #0                         // Set index
20000068:	e3a01000 	mov	r1, #0
2:  mov r2, #0
2000006c:	e3a02000 	mov	r2, #0
    orr r2, r2, r1, LSL #5
20000070:	e1822281 	orr	r2, r2, r1, lsl #5
    orr r2, r2, r0, LSL #30
20000074:	e1822f00 	orr	r2, r2, r0, lsl #30
    mcr p15, 0, r2, c7, c10, 2
20000078:	ee072f5a 	mcr	15, 0, r2, cr7, cr10, {2}
    add r1, r1, #1
2000007c:	e2811001 	add	r1, r1, #1
    cmp r1, r4
20000080:	e1510004 	cmp	r1, r4
    bne 2b
20000084:	1afffff8 	bne	2000006c <reloc+0x54>
    add r0, r0, #1
20000088:	e2800001 	add	r0, r0, #1
    cmp r0, r3
2000008c:	e1500003 	cmp	r0, r3
    bne 1b
20000090:	1afffff4 	bne	20000068 <reloc+0x50>
    dsb
20000094:	f57ff04f 	dsb	sy
    isb
20000098:	f57ff06f 	isb	sy

    // Disable the D-cache
    mrc p15, 0, r0, c1, c0, 0
2000009c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic r0, #(1 << 2)
200000a0:	e3c00004 	bic	r0, r0, #4
    mcr p15, 0, r0, c1, c0, 0
200000a4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dmb
200000a8:	f57ff05f 	dmb	sy
    isb
200000ac:	f57ff06f 	isb	sy

200000b0 <skip_disable_dcache>:
    
skip_disable_dcache:

    // Check if the icache is enabled
    mrc p15, 0, r0, c1, c0, 0
200000b0:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst r0, #(1 << 12)
200000b4:	e3100a01 	tst	r0, #4096	; 0x1000
    beq skip_invalidate_icache
200000b8:	0a000003 	beq	200000cc <skip_invalidate_icache>

    // Invalidate the icache
    mov r0, #0
200000bc:	e3a00000 	mov	r0, #0
    mcr p15, 0, r0, c7, c5, 0
200000c0:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
    dsb
200000c4:	f57ff04f 	dsb	sy
    isb
200000c8:	f57ff06f 	isb	sy

200000cc <skip_invalidate_icache>:

skip_invalidate_icache:

    // Relocation is complete so we can jump to the beginning of DDR
    ldr r1, =ddr_start
200000cc:	e59f1018 	ldr	r1, [pc, #24]	; 200000ec <skip_reloc+0x10>
    dsb
200000d0:	f57ff04f 	dsb	sy
    isb
200000d4:	f57ff06f 	isb	sy
    bx r1
200000d8:	e12fff11 	bx	r1

200000dc <skip_reloc>:
skip_reloc:
    // We require that MMU, interrupt and D-cache is disabled at this point. 
    // This will be the main entry point for the kernel

    // Setup the stack for the kernel SVC entry
    ldr sp, =_svc_stack_e
200000dc:	e59fd010 	ldr	sp, [pc, #16]	; 200000f4 <skip_reloc+0x18>
    isb
200000e0:	f57ff06f 	isb	sy

    // Remember to init the .bss

    ldr r0, =main
200000e4:	e59f000c 	ldr	r0, [pc, #12]	; 200000f8 <skip_reloc+0x1c>
    bx r0
200000e8:	e12fff10 	bx	r0
    ldr r1, =ddr_start
200000ec:	20000000 	.word	0x20000000
    ldr r2, =_kernel_size
200000f0:	00001b90 	.word	0x00001b90
    ldr sp, =_svc_stack_e
200000f4:	200658c0 	.word	0x200658c0
    ldr r0, =main
200000f8:	20000a40 	.word	0x20000a40

Disassembly of section .text:

20000100 <__udivsi3>:
20000100:	1e4a      	subs	r2, r1, #1
20000102:	bf08      	it	eq
20000104:	4770      	bxeq	lr
20000106:	f0c0 8124 	bcc.w	20000352 <__udivsi3+0x252>
2000010a:	4288      	cmp	r0, r1
2000010c:	f240 8116 	bls.w	2000033c <__udivsi3+0x23c>
20000110:	4211      	tst	r1, r2
20000112:	f000 8117 	beq.w	20000344 <__udivsi3+0x244>
20000116:	fab0 f380 	clz	r3, r0
2000011a:	fab1 f281 	clz	r2, r1
2000011e:	eba2 0303 	sub.w	r3, r2, r3
20000122:	f1c3 031f 	rsb	r3, r3, #31
20000126:	a204      	add	r2, pc, #16	; (adr r2, 20000138 <__udivsi3+0x38>)
20000128:	eb02 1303 	add.w	r3, r2, r3, lsl #4
2000012c:	f04f 0200 	mov.w	r2, #0
20000130:	469f      	mov	pc, r3
20000132:	bf00      	nop
20000134:	f3af 8000 	nop.w
20000138:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
2000013c:	bf00      	nop
2000013e:	eb42 0202 	adc.w	r2, r2, r2
20000142:	bf28      	it	cs
20000144:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
20000148:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
2000014c:	bf00      	nop
2000014e:	eb42 0202 	adc.w	r2, r2, r2
20000152:	bf28      	it	cs
20000154:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
20000158:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
2000015c:	bf00      	nop
2000015e:	eb42 0202 	adc.w	r2, r2, r2
20000162:	bf28      	it	cs
20000164:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
20000168:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
2000016c:	bf00      	nop
2000016e:	eb42 0202 	adc.w	r2, r2, r2
20000172:	bf28      	it	cs
20000174:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
20000178:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
2000017c:	bf00      	nop
2000017e:	eb42 0202 	adc.w	r2, r2, r2
20000182:	bf28      	it	cs
20000184:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
20000188:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
2000018c:	bf00      	nop
2000018e:	eb42 0202 	adc.w	r2, r2, r2
20000192:	bf28      	it	cs
20000194:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
20000198:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
2000019c:	bf00      	nop
2000019e:	eb42 0202 	adc.w	r2, r2, r2
200001a2:	bf28      	it	cs
200001a4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
200001a8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
200001ac:	bf00      	nop
200001ae:	eb42 0202 	adc.w	r2, r2, r2
200001b2:	bf28      	it	cs
200001b4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
200001b8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
200001bc:	bf00      	nop
200001be:	eb42 0202 	adc.w	r2, r2, r2
200001c2:	bf28      	it	cs
200001c4:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
200001c8:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
200001cc:	bf00      	nop
200001ce:	eb42 0202 	adc.w	r2, r2, r2
200001d2:	bf28      	it	cs
200001d4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
200001d8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
200001dc:	bf00      	nop
200001de:	eb42 0202 	adc.w	r2, r2, r2
200001e2:	bf28      	it	cs
200001e4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
200001e8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
200001ec:	bf00      	nop
200001ee:	eb42 0202 	adc.w	r2, r2, r2
200001f2:	bf28      	it	cs
200001f4:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
200001f8:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
200001fc:	bf00      	nop
200001fe:	eb42 0202 	adc.w	r2, r2, r2
20000202:	bf28      	it	cs
20000204:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
20000208:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
2000020c:	bf00      	nop
2000020e:	eb42 0202 	adc.w	r2, r2, r2
20000212:	bf28      	it	cs
20000214:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
20000218:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
2000021c:	bf00      	nop
2000021e:	eb42 0202 	adc.w	r2, r2, r2
20000222:	bf28      	it	cs
20000224:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
20000228:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
2000022c:	bf00      	nop
2000022e:	eb42 0202 	adc.w	r2, r2, r2
20000232:	bf28      	it	cs
20000234:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
20000238:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
2000023c:	bf00      	nop
2000023e:	eb42 0202 	adc.w	r2, r2, r2
20000242:	bf28      	it	cs
20000244:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
20000248:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
2000024c:	bf00      	nop
2000024e:	eb42 0202 	adc.w	r2, r2, r2
20000252:	bf28      	it	cs
20000254:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
20000258:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
2000025c:	bf00      	nop
2000025e:	eb42 0202 	adc.w	r2, r2, r2
20000262:	bf28      	it	cs
20000264:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
20000268:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
2000026c:	bf00      	nop
2000026e:	eb42 0202 	adc.w	r2, r2, r2
20000272:	bf28      	it	cs
20000274:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
20000278:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
2000027c:	bf00      	nop
2000027e:	eb42 0202 	adc.w	r2, r2, r2
20000282:	bf28      	it	cs
20000284:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
20000288:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
2000028c:	bf00      	nop
2000028e:	eb42 0202 	adc.w	r2, r2, r2
20000292:	bf28      	it	cs
20000294:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
20000298:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
2000029c:	bf00      	nop
2000029e:	eb42 0202 	adc.w	r2, r2, r2
200002a2:	bf28      	it	cs
200002a4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
200002a8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
200002ac:	bf00      	nop
200002ae:	eb42 0202 	adc.w	r2, r2, r2
200002b2:	bf28      	it	cs
200002b4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
200002b8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
200002bc:	bf00      	nop
200002be:	eb42 0202 	adc.w	r2, r2, r2
200002c2:	bf28      	it	cs
200002c4:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
200002c8:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
200002cc:	bf00      	nop
200002ce:	eb42 0202 	adc.w	r2, r2, r2
200002d2:	bf28      	it	cs
200002d4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
200002d8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
200002dc:	bf00      	nop
200002de:	eb42 0202 	adc.w	r2, r2, r2
200002e2:	bf28      	it	cs
200002e4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
200002e8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
200002ec:	bf00      	nop
200002ee:	eb42 0202 	adc.w	r2, r2, r2
200002f2:	bf28      	it	cs
200002f4:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
200002f8:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
200002fc:	bf00      	nop
200002fe:	eb42 0202 	adc.w	r2, r2, r2
20000302:	bf28      	it	cs
20000304:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
20000308:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
2000030c:	bf00      	nop
2000030e:	eb42 0202 	adc.w	r2, r2, r2
20000312:	bf28      	it	cs
20000314:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
20000318:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
2000031c:	bf00      	nop
2000031e:	eb42 0202 	adc.w	r2, r2, r2
20000322:	bf28      	it	cs
20000324:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
20000328:	ebb0 0f01 	cmp.w	r0, r1
2000032c:	bf00      	nop
2000032e:	eb42 0202 	adc.w	r2, r2, r2
20000332:	bf28      	it	cs
20000334:	eba0 0001 	subcs.w	r0, r0, r1
20000338:	4610      	mov	r0, r2
2000033a:	4770      	bx	lr
2000033c:	bf0c      	ite	eq
2000033e:	2001      	moveq	r0, #1
20000340:	2000      	movne	r0, #0
20000342:	4770      	bx	lr
20000344:	fab1 f281 	clz	r2, r1
20000348:	f1c2 021f 	rsb	r2, r2, #31
2000034c:	fa20 f002 	lsr.w	r0, r0, r2
20000350:	4770      	bx	lr
20000352:	b108      	cbz	r0, 20000358 <__udivsi3+0x258>
20000354:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000358:	f000 b80e 	b.w	20000378 <__aeabi_idiv0>

2000035c <__aeabi_uidivmod>:
2000035c:	2900      	cmp	r1, #0
2000035e:	d0f8      	beq.n	20000352 <__udivsi3+0x252>
20000360:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
20000364:	f7ff fecc 	bl	20000100 <__udivsi3>
20000368:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
2000036c:	fb02 f300 	mul.w	r3, r2, r0
20000370:	eba1 0103 	sub.w	r1, r1, r3
20000374:	4770      	bx	lr
20000376:	bf00      	nop

20000378 <__aeabi_idiv0>:
20000378:	4770      	bx	lr
2000037a:	bf00      	nop

2000037c <print_format_to_buf_arg>:
    if (*buf < end) {
        *(*buf)++ = c;
    }
}

u32 print_format_to_buf_arg(char* buf, u32 len, const char* str, va_list arg) {
2000037c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
20000380:	e24dd05c 	sub	sp, sp, #92	; 0x5c
20000384:	e1a0a000 	mov	sl, r0
20000388:	e58d1004 	str	r1, [sp, #4]
2000038c:	e1a0c002 	mov	ip, r2
    // Save the end of the buffer so that we can detect overflow
    char* const end = buf + len;
20000390:	e080b001 	add	fp, r0, r1

    for (; *str; str++) {
20000394:	e5d21000 	ldrb	r1, [r2]
20000398:	e3510000 	cmp	r1, #0
2000039c:	0a000166 	beq	2000093c <print_format_to_buf_arg+0x5c0>
200003a0:	e1a02003 	mov	r2, r3
            }

            // Convert the number to string representation
            u32 num_pos = (u32)num;
            do {
                num_buf[index++] = number_lookup[num_pos % base] | lowercase;
200003a4:	e3013528 	movw	r3, #5416	; 0x1528
200003a8:	e3423000 	movt	r3, #8192	; 0x2000
200003ac:	e58d3000 	str	r3, [sp]
200003b0:	e300335d 	movw	r3, #861	; 0x35d
200003b4:	e3423000 	movt	r3, #8192	; 0x2000
200003b8:	e58d300c 	str	r3, [sp, #12]
                num_pos /= base;
200003bc:	e3003101 	movw	r3, #257	; 0x101
200003c0:	e3423000 	movt	r3, #8192	; 0x2000
200003c4:	e58d3010 	str	r3, [sp, #16]
        *(*buf)++ = c;
200003c8:	e1a0900b 	mov	r9, fp
200003cc:	ea000084 	b	200005e4 <print_format_to_buf_arg+0x268>
        while (*++str) {
200003d0:	e28c4001 	add	r4, ip, #1
200003d4:	e5dc3001 	ldrb	r3, [ip, #1]
200003d8:	e3530000 	cmp	r3, #0
        u16 flags = 0;
200003dc:	03a05000 	moveq	r5, #0
        while (*++str) {
200003e0:	0a000016 	beq	20000440 <print_format_to_buf_arg+0xc4>
        u16 flags = 0;
200003e4:	e3a05000 	mov	r5, #0
200003e8:	ea000003 	b	200003fc <print_format_to_buf_arg+0x80>
            else if (*str == ' ') flags |= FLAG_SIGN_IGNORE;
200003ec:	e3855008 	orr	r5, r5, #8
        while (*++str) {
200003f0:	e5f43001 	ldrb	r3, [r4, #1]!
200003f4:	e3530000 	cmp	r3, #0
200003f8:	0a000010 	beq	20000440 <print_format_to_buf_arg+0xc4>
200003fc:	e2441001 	sub	r1, r4, #1
            if      (*str == '!') flags |= FLAG_PREFIX;
20000400:	e3530021 	cmp	r3, #33	; 0x21
20000404:	03855001 	orreq	r5, r5, #1
20000408:	0afffff8 	beq	200003f0 <print_format_to_buf_arg+0x74>
            else if (*str == '<') flags |= FLAG_LEFT;
2000040c:	e353003c 	cmp	r3, #60	; 0x3c
20000410:	03855002 	orreq	r5, r5, #2
20000414:	0afffff5 	beq	200003f0 <print_format_to_buf_arg+0x74>
            else if (*str == '0') flags |= FLAG_ZERO;
20000418:	e3530030 	cmp	r3, #48	; 0x30
2000041c:	03855004 	orreq	r5, r5, #4
20000420:	0afffff2 	beq	200003f0 <print_format_to_buf_arg+0x74>
            else if (*str == '+') flags |= FLAG_SIGN_FORCE;
20000424:	e353002b 	cmp	r3, #43	; 0x2b
20000428:	03855010 	orreq	r5, r5, #16
2000042c:	0affffef 	beq	200003f0 <print_format_to_buf_arg+0x74>
            else if (*str == ' ') flags |= FLAG_SIGN_IGNORE;
20000430:	e3530020 	cmp	r3, #32
20000434:	0affffec 	beq	200003ec <print_format_to_buf_arg+0x70>
        if (*str == ':') {
20000438:	e353003a 	cmp	r3, #58	; 0x3a
            str++;
2000043c:	02814002 	addeq	r4, r1, #2
        if (*str == '_') {
20000440:	e5d43000 	ldrb	r3, [r4]
20000444:	e353005f 	cmp	r3, #95	; 0x5f
            width = (i32)va_arg(arg, int);
20000448:	04927004 	ldreq	r7, [r2], #4
            str++;
2000044c:	02844001 	addeq	r4, r4, #1
        if (*str == '_') {
20000450:	0a000004 	beq	20000468 <print_format_to_buf_arg+0xec>
        } else if (*str >= '0' && *str <= '9') {
20000454:	e2431030 	sub	r1, r3, #48	; 0x30
20000458:	e6ef1071 	uxtb	r1, r1
2000045c:	e3510009 	cmp	r1, #9
        i32 width = -1;
20000460:	83e07000 	mvnhi	r7, #0
        } else if (*str >= '0' && *str <= '9') {
20000464:	9a000041 	bls	20000570 <print_format_to_buf_arg+0x1f4>
        if (*str == ':') {
20000468:	e5d43000 	ldrb	r3, [r4]
2000046c:	e353003a 	cmp	r3, #58	; 0x3a
            str++;
20000470:	02844001 	addeq	r4, r4, #1
        switch (*str++) {
20000474:	e5d43000 	ldrb	r3, [r4]
20000478:	e2433042 	sub	r3, r3, #66	; 0x42
2000047c:	e3530039 	cmp	r3, #57	; 0x39
20000480:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
20000484:	ea000052 	b	200005d4 <print_format_to_buf_arg+0x258>
20000488:	20000624 	.word	0x20000624
2000048c:	20000600 	.word	0x20000600
20000490:	200005d4 	.word	0x200005d4
20000494:	200005d4 	.word	0x200005d4
20000498:	200005d4 	.word	0x200005d4
2000049c:	200005d4 	.word	0x200005d4
200004a0:	200005d4 	.word	0x200005d4
200004a4:	200005d4 	.word	0x200005d4
200004a8:	200005d4 	.word	0x200005d4
200004ac:	200005d4 	.word	0x200005d4
200004b0:	200005d4 	.word	0x200005d4
200004b4:	200005d4 	.word	0x200005d4
200004b8:	200005d4 	.word	0x200005d4
200004bc:	200005d4 	.word	0x200005d4
200004c0:	2000062c 	.word	0x2000062c
200004c4:	200005d4 	.word	0x200005d4
200004c8:	2000063c 	.word	0x2000063c
200004cc:	200005a0 	.word	0x200005a0
200004d0:	200005d4 	.word	0x200005d4
200004d4:	200005d4 	.word	0x200005d4
200004d8:	200005d4 	.word	0x200005d4
200004dc:	200005d4 	.word	0x200005d4
200004e0:	20000598 	.word	0x20000598
200004e4:	200005d4 	.word	0x200005d4
200004e8:	200005d4 	.word	0x200005d4
200004ec:	200005d4 	.word	0x200005d4
200004f0:	200005d4 	.word	0x200005d4
200004f4:	200005d4 	.word	0x200005d4
200004f8:	200005d4 	.word	0x200005d4
200004fc:	200005d4 	.word	0x200005d4
20000500:	200005d4 	.word	0x200005d4
20000504:	200005d4 	.word	0x200005d4
20000508:	20000624 	.word	0x20000624
2000050c:	20000600 	.word	0x20000600
20000510:	20000658 	.word	0x20000658
20000514:	200005d4 	.word	0x200005d4
20000518:	200005d4 	.word	0x200005d4
2000051c:	200005d4 	.word	0x200005d4
20000520:	200005d4 	.word	0x200005d4
20000524:	2000060c 	.word	0x2000060c
20000528:	200005d4 	.word	0x200005d4
2000052c:	200005d4 	.word	0x200005d4
20000530:	200005d4 	.word	0x200005d4
20000534:	200005d4 	.word	0x200005d4
20000538:	200005d4 	.word	0x200005d4
2000053c:	200005d4 	.word	0x200005d4
20000540:	2000062c 	.word	0x2000062c
20000544:	200005d4 	.word	0x200005d4
20000548:	2000063c 	.word	0x2000063c
2000054c:	200005a0 	.word	0x200005a0
20000550:	200005d4 	.word	0x200005d4
20000554:	20000658 	.word	0x20000658
20000558:	200005d4 	.word	0x200005d4
2000055c:	200005d4 	.word	0x200005d4
20000560:	20000618 	.word	0x20000618
20000564:	200005d4 	.word	0x200005d4
20000568:	200005d4 	.word	0x200005d4
2000056c:	2000064c 	.word	0x2000064c
            width = 0;
20000570:	e3a07000 	mov	r7, #0
                width = width * 10 + (*str++ - '0');
20000574:	e3a0000a 	mov	r0, #10
20000578:	e2433030 	sub	r3, r3, #48	; 0x30
2000057c:	e0273790 	mla	r7, r0, r7, r3
            while (*str >= '0' && *str <= '9') {
20000580:	e5f43001 	ldrb	r3, [r4, #1]!
20000584:	e2431030 	sub	r1, r3, #48	; 0x30
20000588:	e6ef1071 	uxtb	r1, r1
2000058c:	e3510009 	cmp	r1, #9
20000590:	9afffff8 	bls	20000578 <print_format_to_buf_arg+0x1fc>
20000594:	eaffffb3 	b	20000468 <print_format_to_buf_arg+0xec>
        switch (*str++) {
20000598:	e3a0b010 	mov	fp, #16
2000059c:	ea000001 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_STRING;
200005a0:	e3855080 	orr	r5, r5, #128	; 0x80
        u8 base = 10;
200005a4:	e3a0b00a 	mov	fp, #10
        if (flags & FLAG_CHAR) {
200005a8:	e3150c01 	tst	r5, #256	; 0x100
200005ac:	0a00002b 	beq	20000660 <print_format_to_buf_arg+0x2e4>
            put_char((char)va_arg(arg, int), &buf, end);
200005b0:	e2823004 	add	r3, r2, #4
    if (*buf < end) {
200005b4:	e159000a 	cmp	r9, sl
            put_char((char)va_arg(arg, int), &buf, end);
200005b8:	91a02003 	movls	r2, r3
200005bc:	85922000 	ldrhi	r2, [r2]
200005c0:	84ca2001 	strbhi	r2, [sl], #1
200005c4:	81a02003 	movhi	r2, r3
            }
        }

        // If the user don't write ending bracket we don't skrip the next 
        // character
        if (*str != '}') {
200005c8:	e5d43001 	ldrb	r3, [r4, #1]
200005cc:	e353007d 	cmp	r3, #125	; 0x7d
        switch (*str++) {
200005d0:	02844001 	addeq	r4, r4, #1
    for (; *str; str++) {
200005d4:	e284c001 	add	ip, r4, #1
200005d8:	e5d41001 	ldrb	r1, [r4, #1]
200005dc:	e3510000 	cmp	r1, #0
200005e0:	0a0000d4 	beq	20000938 <print_format_to_buf_arg+0x5bc>
        if (*str != '{') {
200005e4:	e351007b 	cmp	r1, #123	; 0x7b
200005e8:	0affff78 	beq	200003d0 <print_format_to_buf_arg+0x54>
    if (*buf < end) {
200005ec:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200005f0:	84ca1001 	strbhi	r1, [sl], #1
200005f4:	81a0400c 	movhi	r4, ip
    if (*buf < end) {
200005f8:	91a0400c 	movls	r4, ip
200005fc:	eafffff4 	b	200005d4 <print_format_to_buf_arg+0x258>
                flags |= FLAG_CHAR;
20000600:	e3855c01 	orr	r5, r5, #256	; 0x100
        u8 base = 10;
20000604:	e3a0b00a 	mov	fp, #10
                break;
20000608:	eaffffe6 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_SIGN;
2000060c:	e3855040 	orr	r5, r5, #64	; 0x40
        u8 base = 10;
20000610:	e3a0b00a 	mov	fp, #10
20000614:	eaffffe3 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_LOWERCASE;
20000618:	e3855020 	orr	r5, r5, #32
                base = 16;
2000061c:	e3a0b010 	mov	fp, #16
20000620:	eaffffe0 	b	200005a8 <print_format_to_buf_arg+0x22c>
                base = 2;
20000624:	e3a0b002 	mov	fp, #2
                break;
20000628:	eaffffde 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_PREFIX;
2000062c:	e3855001 	orr	r5, r5, #1
                base = 16;
20000630:	e3a0b010 	mov	fp, #16
                width = 8;
20000634:	e3a07008 	mov	r7, #8
                break;
20000638:	eaffffda 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_PREFIX | FLAG_ZERO;
2000063c:	e3855005 	orr	r5, r5, #5
                base = 2;
20000640:	e3a0b002 	mov	fp, #2
                width = 34;
20000644:	e3a07022 	mov	r7, #34	; 0x22
                break;
20000648:	eaffffd6 	b	200005a8 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_BRACKET;
2000064c:	e3855c02 	orr	r5, r5, #512	; 0x200
        u8 base = 10;
20000650:	e3a0b00a 	mov	fp, #10
                break;
20000654:	eaffffd3 	b	200005a8 <print_format_to_buf_arg+0x22c>
        u8 base = 10;
20000658:	e3a0b00a 	mov	fp, #10
2000065c:	eaffffd1 	b	200005a8 <print_format_to_buf_arg+0x22c>
        } else if (flags & FLAG_STRING) {
20000660:	e3150080 	tst	r5, #128	; 0x80
20000664:	0a000035 	beq	20000740 <print_format_to_buf_arg+0x3c4>
            const char* ptr = (const char *)va_arg(arg, char *);
20000668:	e4920004 	ldr	r0, [r2], #4
            if (width < 0) {
2000066c:	e3570000 	cmp	r7, #0
20000670:	ba000023 	blt	20000704 <print_format_to_buf_arg+0x388>
                for (i = 0; (i < width) && ptr[i]; i++);
20000674:	e1a0e007 	mov	lr, r7
20000678:	0a0000df 	beq	200009fc <print_format_to_buf_arg+0x680>
2000067c:	e2403001 	sub	r3, r0, #1
20000680:	e3a0c000 	mov	ip, #0
20000684:	e5f31001 	ldrb	r1, [r3, #1]!
20000688:	e3510000 	cmp	r1, #0
2000068c:	0a000025 	beq	20000728 <print_format_to_buf_arg+0x3ac>
20000690:	e28cc001 	add	ip, ip, #1
20000694:	e15c000e 	cmp	ip, lr
20000698:	1afffff9 	bne	20000684 <print_format_to_buf_arg+0x308>
                if ((flags & FLAG_LEFT) == 0) {
2000069c:	e2155002 	ands	r5, r5, #2
200006a0:	0a0000aa 	beq	20000950 <print_format_to_buf_arg+0x5d4>
                u32 padding = width - i;
200006a4:	e3a01000 	mov	r1, #0
                while (i--) {
200006a8:	e24e3001 	sub	r3, lr, #1
200006ac:	e35e0000 	cmp	lr, #0
200006b0:	0a000009 	beq	200006dc <print_format_to_buf_arg+0x360>
200006b4:	e2833001 	add	r3, r3, #1
200006b8:	e0803003 	add	r3, r0, r3
                    put_char(*ptr++, &buf, end);
200006bc:	e2800001 	add	r0, r0, #1
    if (*buf < end) {
200006c0:	e159000a 	cmp	r9, sl
                    put_char(*ptr++, &buf, end);
200006c4:	8550c001 	ldrbhi	ip, [r0, #-1]
        *(*buf)++ = c;
200006c8:	84cac001 	strbhi	ip, [sl], #1
                while (i--) {
200006cc:	e1500003 	cmp	r0, r3
200006d0:	1afffff9 	bne	200006bc <print_format_to_buf_arg+0x340>
                if (flags & FLAG_LEFT) {
200006d4:	e3550000 	cmp	r5, #0
200006d8:	0affffba 	beq	200005c8 <print_format_to_buf_arg+0x24c>
                    while (padding--) {
200006dc:	e2413001 	sub	r3, r1, #1
200006e0:	e3510000 	cmp	r1, #0
200006e4:	0affffb7 	beq	200005c8 <print_format_to_buf_arg+0x24c>
    if (*buf < end) {
200006e8:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200006ec:	83a01020 	movhi	r1, #32
200006f0:	84ca1001 	strbhi	r1, [sl], #1
                    while (padding--) {
200006f4:	e2433001 	sub	r3, r3, #1
200006f8:	e3730001 	cmn	r3, #1
200006fc:	1afffff9 	bne	200006e8 <print_format_to_buf_arg+0x36c>
20000700:	eaffffb0 	b	200005c8 <print_format_to_buf_arg+0x24c>
                while (*ptr) {
20000704:	e5d03000 	ldrb	r3, [r0]
20000708:	e3530000 	cmp	r3, #0
2000070c:	0affffad 	beq	200005c8 <print_format_to_buf_arg+0x24c>
    if (*buf < end) {
20000710:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
20000714:	84ca3001 	strbhi	r3, [sl], #1
                while (*ptr) {
20000718:	e5f03001 	ldrb	r3, [r0, #1]!
2000071c:	e3530000 	cmp	r3, #0
20000720:	1afffffa 	bne	20000710 <print_format_to_buf_arg+0x394>
20000724:	eaffffa7 	b	200005c8 <print_format_to_buf_arg+0x24c>
                u32 padding = width - i;
20000728:	e04e100c 	sub	r1, lr, ip
                if ((flags & FLAG_LEFT) == 0) {
2000072c:	e2155002 	ands	r5, r5, #2
                u32 padding = width - i;
20000730:	01a0e001 	moveq	lr, r1
                if ((flags & FLAG_LEFT) == 0) {
20000734:	0a0000b4 	beq	20000a0c <print_format_to_buf_arg+0x690>
20000738:	e1a0e00c 	mov	lr, ip
2000073c:	eaffffd9 	b	200006a8 <print_format_to_buf_arg+0x32c>
            char pad_char = (flags & FLAG_ZERO) ? '0' : ' ';
20000740:	e3150004 	tst	r5, #4
20000744:	13a03030 	movne	r3, #48	; 0x30
20000748:	03a03020 	moveq	r3, #32
2000074c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
            i32 num = (i32)va_arg(arg, int);
20000750:	e1a03002 	mov	r3, r2
20000754:	e4936004 	ldr	r6, [r3], #4
20000758:	e58d3014 	str	r3, [sp, #20]
            u8 lowercase = (flags & FLAG_LOWERCASE) ? FLAG_LOWERCASE : 0;
2000075c:	e2053020 	and	r3, r5, #32
20000760:	e1a02003 	mov	r2, r3
            if (num < 0 && (flags & FLAG_SIGN)) {
20000764:	e3560000 	cmp	r6, #0
20000768:	ba00003b 	blt	2000085c <print_format_to_buf_arg+0x4e0>
                sign = '+';
2000076c:	e3150010 	tst	r5, #16
20000770:	03a03000 	moveq	r3, #0
20000774:	13a0302b 	movne	r3, #43	; 0x2b
20000778:	e58d3008 	str	r3, [sp, #8]
                sign = ' ';
2000077c:	e3150008 	tst	r5, #8
20000780:	e59d3008 	ldr	r3, [sp, #8]
20000784:	13a03020 	movne	r3, #32
20000788:	e58d3008 	str	r3, [sp, #8]
            u32 num_pos = (u32)num;
2000078c:	e1a03006 	mov	r3, r6
20000790:	e28d8034 	add	r8, sp, #52	; 0x34
            u32 index = 0;
20000794:	e3a06000 	mov	r6, #0
20000798:	e58d4018 	str	r4, [sp, #24]
2000079c:	e58d701c 	str	r7, [sp, #28]
200007a0:	e1a04003 	mov	r4, r3
200007a4:	e58d9020 	str	r9, [sp, #32]
200007a8:	e1a07002 	mov	r7, r2
200007ac:	e58d5024 	str	r5, [sp, #36]	; 0x24
200007b0:	e58da028 	str	sl, [sp, #40]	; 0x28
200007b4:	e59d900c 	ldr	r9, [sp, #12]
200007b8:	e59da010 	ldr	sl, [sp, #16]
                num_buf[index++] = number_lookup[num_pos % base] | lowercase;
200007bc:	e2866001 	add	r6, r6, #1
200007c0:	e1a0100b 	mov	r1, fp
200007c4:	e1a00004 	mov	r0, r4
200007c8:	e12fff39 	blx	r9
200007cc:	e59d3000 	ldr	r3, [sp]
200007d0:	e7d33001 	ldrb	r3, [r3, r1]
200007d4:	e1873003 	orr	r3, r7, r3
200007d8:	e4c83001 	strb	r3, [r8], #1
                num_pos /= base;
200007dc:	e1a05004 	mov	r5, r4
200007e0:	e1a0100b 	mov	r1, fp
200007e4:	e1a00004 	mov	r0, r4
200007e8:	e12fff3a 	blx	sl
200007ec:	e1a04000 	mov	r4, r0
            } while(num_pos);
200007f0:	e15b0005 	cmp	fp, r5
200007f4:	9afffff0 	bls	200007bc <print_format_to_buf_arg+0x440>
200007f8:	e59d4018 	ldr	r4, [sp, #24]
200007fc:	e59d701c 	ldr	r7, [sp, #28]
20000800:	e59d9020 	ldr	r9, [sp, #32]
20000804:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
20000808:	e59da028 	ldr	sl, [sp, #40]	; 0x28
            if (flags & FLAG_PREFIX) {
2000080c:	e2152001 	ands	r2, r5, #1
            u8 sign_prefix_pad = 0;
20000810:	03a03000 	moveq	r3, #0
            if (flags & FLAG_PREFIX) {
20000814:	0a000003 	beq	20000828 <print_format_to_buf_arg+0x4ac>
                    sign_prefix_pad += 2;
20000818:	e35b0002 	cmp	fp, #2
2000081c:	135b0010 	cmpne	fp, #16
20000820:	13a03000 	movne	r3, #0
20000824:	03a03002 	moveq	r3, #2
            if (sign) {
20000828:	e59d1008 	ldr	r1, [sp, #8]
2000082c:	e3510000 	cmp	r1, #0
20000830:	0a00004b 	beq	20000964 <print_format_to_buf_arg+0x5e8>
            if (width >= 0) {
20000834:	e3570000 	cmp	r7, #0
            u32 padding = 0;
20000838:	b3a01000 	movlt	r1, #0
            if (width >= 0) {
2000083c:	ba000053 	blt	20000990 <print_format_to_buf_arg+0x614>
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
20000840:	e2830001 	add	r0, r3, #1
20000844:	e1a01007 	mov	r1, r7
20000848:	e0803006 	add	r3, r0, r6
2000084c:	e1530007 	cmp	r3, r7
20000850:	83a01000 	movhi	r1, #0
20000854:	8a00004d 	bhi	20000990 <print_format_to_buf_arg+0x614>
20000858:	ea00004a 	b	20000988 <print_format_to_buf_arg+0x60c>
            if (num < 0 && (flags & FLAG_SIGN)) {
2000085c:	e3150040 	tst	r5, #64	; 0x40
20000860:	0affffc1 	beq	2000076c <print_format_to_buf_arg+0x3f0>
                num = -num;
20000864:	e2666000 	rsb	r6, r6, #0
                sign = '-';
20000868:	e3a0302d 	mov	r3, #45	; 0x2d
2000086c:	e58d3008 	str	r3, [sp, #8]
20000870:	eaffffc1 	b	2000077c <print_format_to_buf_arg+0x400>
    if (*buf < end) {
20000874:	e159000a 	cmp	r9, sl
20000878:	9a00004e 	bls	200009b8 <print_format_to_buf_arg+0x63c>
        *(*buf)++ = c;
2000087c:	e1a0300a 	mov	r3, sl
20000880:	e3a02030 	mov	r2, #48	; 0x30
20000884:	e4c32001 	strb	r2, [r3], #1
    if (*buf < end) {
20000888:	e1590003 	cmp	r9, r3
2000088c:	9a00000e 	bls	200008cc <print_format_to_buf_arg+0x550>
        *(*buf)++ = c;
20000890:	e3a03078 	mov	r3, #120	; 0x78
20000894:	e5ca3001 	strb	r3, [sl, #1]
20000898:	e28aa002 	add	sl, sl, #2
2000089c:	ea000045 	b	200009b8 <print_format_to_buf_arg+0x63c>
    if (*buf < end) {
200008a0:	e159000a 	cmp	r9, sl
200008a4:	9a000043 	bls	200009b8 <print_format_to_buf_arg+0x63c>
        *(*buf)++ = c;
200008a8:	e1a0300a 	mov	r3, sl
200008ac:	e3a02030 	mov	r2, #48	; 0x30
200008b0:	e4c32001 	strb	r2, [r3], #1
    if (*buf < end) {
200008b4:	e1590003 	cmp	r9, r3
200008b8:	9a000005 	bls	200008d4 <print_format_to_buf_arg+0x558>
        *(*buf)++ = c;
200008bc:	e3a03062 	mov	r3, #98	; 0x62
200008c0:	e5ca3001 	strb	r3, [sl, #1]
200008c4:	e28aa002 	add	sl, sl, #2
200008c8:	ea00003a 	b	200009b8 <print_format_to_buf_arg+0x63c>
200008cc:	e1a0a003 	mov	sl, r3
200008d0:	ea000038 	b	200009b8 <print_format_to_buf_arg+0x63c>
200008d4:	e1a0a003 	mov	sl, r3
200008d8:	ea000036 	b	200009b8 <print_format_to_buf_arg+0x63c>
                while (padding--) {
200008dc:	e2413001 	sub	r3, r1, #1
200008e0:	e3510000 	cmp	r1, #0
200008e4:	0a00001c 	beq	2000095c <print_format_to_buf_arg+0x5e0>
200008e8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    if (*buf < end) {
200008ec:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200008f0:	84ca2001 	strbhi	r2, [sl], #1
                while (padding--) {
200008f4:	e2433001 	sub	r3, r3, #1
200008f8:	e3730001 	cmn	r3, #1
200008fc:	1afffffa 	bne	200008ec <print_format_to_buf_arg+0x570>
20000900:	e1a01003 	mov	r1, r3
            while (index) {
20000904:	e3560000 	cmp	r6, #0
20000908:	1a00002e 	bne	200009c8 <print_format_to_buf_arg+0x64c>
2000090c:	ea000038 	b	200009f4 <print_format_to_buf_arg+0x678>
                while (padding--) {
20000910:	e2413001 	sub	r3, r1, #1
20000914:	e3510000 	cmp	r1, #0
20000918:	0a000035 	beq	200009f4 <print_format_to_buf_arg+0x678>
2000091c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    if (*buf < end) {
20000920:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
20000924:	84ca2001 	strbhi	r2, [sl], #1
                while (padding--) {
20000928:	e2433001 	sub	r3, r3, #1
2000092c:	e3730001 	cmn	r3, #1
20000930:	1afffffa 	bne	20000920 <print_format_to_buf_arg+0x5a4>
20000934:	ea00002e 	b	200009f4 <print_format_to_buf_arg+0x678>
20000938:	e1a0b009 	mov	fp, r9
            str--;
        }
    }
    return buf + len - end;
2000093c:	e59d3004 	ldr	r3, [sp, #4]
20000940:	e08a0003 	add	r0, sl, r3
20000944:	e040000b 	sub	r0, r0, fp
}
20000948:	e28dd05c 	add	sp, sp, #92	; 0x5c
2000094c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                for (i = 0; (i < width) && ptr[i]; i++);
20000950:	e1a0c00e 	mov	ip, lr
                    while (padding--) {
20000954:	e3e01000 	mvn	r1, #0
20000958:	ea000034 	b	20000a30 <print_format_to_buf_arg+0x6b4>
                while (padding--) {
2000095c:	e1a01003 	mov	r1, r3
20000960:	eaffffe7 	b	20000904 <print_format_to_buf_arg+0x588>
            if (width >= 0) {
20000964:	e3570000 	cmp	r7, #0
            u32 padding = 0;
20000968:	b3a01000 	movlt	r1, #0
            if (width >= 0) {
2000096c:	ba00000b 	blt	200009a0 <print_format_to_buf_arg+0x624>
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
20000970:	e1a00003 	mov	r0, r3
20000974:	e1a01007 	mov	r1, r7
20000978:	e0863003 	add	r3, r6, r3
2000097c:	e1530007 	cmp	r3, r7
20000980:	83a01000 	movhi	r1, #0
20000984:	8a000005 	bhi	200009a0 <print_format_to_buf_arg+0x624>
                    width - index - sign_prefix_pad;
20000988:	e0411006 	sub	r1, r1, r6
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
2000098c:	e0411000 	sub	r1, r1, r0
    if (*buf < end) {
20000990:	e59d3008 	ldr	r3, [sp, #8]
20000994:	e3530000 	cmp	r3, #0
20000998:	1159000a 	cmpne	r9, sl
        *(*buf)++ = c;
2000099c:	84ca3001 	strbhi	r3, [sl], #1
            if (flags & FLAG_PREFIX) {
200009a0:	e3520000 	cmp	r2, #0
200009a4:	0a000003 	beq	200009b8 <print_format_to_buf_arg+0x63c>
                if (base == 16) {
200009a8:	e35b0010 	cmp	fp, #16
200009ac:	0affffb0 	beq	20000874 <print_format_to_buf_arg+0x4f8>
                } else if (base == 2) {
200009b0:	e35b0002 	cmp	fp, #2
200009b4:	0affffb9 	beq	200008a0 <print_format_to_buf_arg+0x524>
            if ((flags & FLAG_LEFT) == 0) {
200009b8:	e2155002 	ands	r5, r5, #2
200009bc:	0affffc6 	beq	200008dc <print_format_to_buf_arg+0x560>
            while (index) {
200009c0:	e3560000 	cmp	r6, #0
200009c4:	0affffd1 	beq	20000910 <print_format_to_buf_arg+0x594>
200009c8:	e28d3034 	add	r3, sp, #52	; 0x34
200009cc:	e0833006 	add	r3, r3, r6
    if (*buf < end) {
200009d0:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200009d4:	85532001 	ldrbhi	r2, [r3, #-1]
200009d8:	84ca2001 	strbhi	r2, [sl], #1
            while (index) {
200009dc:	e2433001 	sub	r3, r3, #1
200009e0:	e28d2034 	add	r2, sp, #52	; 0x34
200009e4:	e1520003 	cmp	r2, r3
200009e8:	1afffff8 	bne	200009d0 <print_format_to_buf_arg+0x654>
            if (flags & FLAG_LEFT) {
200009ec:	e3550000 	cmp	r5, #0
200009f0:	1affffc6 	bne	20000910 <print_format_to_buf_arg+0x594>
            i32 num = (i32)va_arg(arg, int);
200009f4:	e59d2014 	ldr	r2, [sp, #20]
200009f8:	eafffef2 	b	200005c8 <print_format_to_buf_arg+0x24c>
                if ((flags & FLAG_LEFT) == 0) {
200009fc:	e2155002 	ands	r5, r5, #2
                u32 padding = width - i;
20000a00:	11a01007 	movne	r1, r7
                if ((flags & FLAG_LEFT) == 0) {
20000a04:	1affff34 	bne	200006dc <print_format_to_buf_arg+0x360>
                for (i = 0; (i < width) && ptr[i]; i++);
20000a08:	e1a0c00e 	mov	ip, lr
                    while (padding--) {
20000a0c:	e24e1001 	sub	r1, lr, #1
20000a10:	e35e0000 	cmp	lr, #0
20000a14:	0a000005 	beq	20000a30 <print_format_to_buf_arg+0x6b4>
    if (*buf < end) {
20000a18:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
20000a1c:	83a03020 	movhi	r3, #32
20000a20:	84ca3001 	strbhi	r3, [sl], #1
                    while (padding--) {
20000a24:	e2411001 	sub	r1, r1, #1
20000a28:	e3710001 	cmn	r1, #1
20000a2c:	1afffff9 	bne	20000a18 <print_format_to_buf_arg+0x69c>
                while (i--) {
20000a30:	e24c3001 	sub	r3, ip, #1
20000a34:	e35c0000 	cmp	ip, #0
20000a38:	1affff1d 	bne	200006b4 <print_format_to_buf_arg+0x338>
20000a3c:	eafffee1 	b	200005c8 <print_format_to_buf_arg+0x24c>

20000a40 <main>:
#include <chaos/panic.h>
#include <chaos/network.h>
#include <chaos/nic.h>
#include <chaos/cache.h>

void main() {
20000a40:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}

    kprint("\n\nStarting chaos kernel v1.0\n");
20000a44:	e301053c 	movw	r0, #5436	; 0x153c
20000a48:	e3420000 	movt	r0, #8192	; 0x2000
20000a4c:	e3003b08 	movw	r3, #2824	; 0xb08
20000a50:	e3423000 	movt	r3, #8192	; 0x2000
20000a54:	e12fff33 	blx	r3

    network_start();
20000a58:	e3003cf0 	movw	r3, #3312	; 0xcf0
20000a5c:	e3423000 	movt	r3, #8192	; 0x2000
20000a60:	e12fff33 	blx	r3

    while (1) {
        for (u32 i = 0; i < 500000; i++) {
            asm ("nop");
        }
        struct netbuf* buf = nic_receive();
20000a64:	e301531c 	movw	r5, #4892	; 0x131c
20000a68:	e3425000 	movt	r5, #8192	; 0x2000
        if (buf) {
            kprint("Got a packet => {d}\n", buf->len);
20000a6c:	e301855c 	movw	r8, #5468	; 0x155c
20000a70:	e3428000 	movt	r8, #8192	; 0x2000
20000a74:	e3006b08 	movw	r6, #2824	; 0xb08
20000a78:	e3426000 	movt	r6, #8192	; 0x2000
20000a7c:	ea000006 	b	20000a9c <main+0x5c>
            for (u32 i = 0; i < buf->len; i++) {
                kprint("{0:2:x} ", buf->buf[i]);
            }
            kprint("\n\n");
20000a80:	e3010580 	movw	r0, #5504	; 0x1580
20000a84:	e3420000 	movt	r0, #8192	; 0x2000
20000a88:	e12fff36 	blx	r6

            // Free the netbuffer
            free_netbuf(buf);
20000a8c:	e1a00004 	mov	r0, r4
20000a90:	e3003ccc 	movw	r3, #3276	; 0xccc
20000a94:	e3423000 	movt	r3, #8192	; 0x2000
20000a98:	e12fff33 	blx	r3
void main() {
20000a9c:	e30a3120 	movw	r3, #41248	; 0xa120
20000aa0:	e3403007 	movt	r3, #7
            asm ("nop");
20000aa4:	e320f000 	nop	{0}
        for (u32 i = 0; i < 500000; i++) {
20000aa8:	e2533001 	subs	r3, r3, #1
20000aac:	1afffffc 	bne	20000aa4 <main+0x64>
        struct netbuf* buf = nic_receive();
20000ab0:	e12fff35 	blx	r5
        if (buf) {
20000ab4:	e2504000 	subs	r4, r0, #0
20000ab8:	0afffff7 	beq	20000a9c <main+0x5c>
            kprint("Got a packet => {d}\n", buf->len);
20000abc:	e594161c 	ldr	r1, [r4, #1564]	; 0x61c
20000ac0:	e1a00008 	mov	r0, r8
20000ac4:	e12fff36 	blx	r6
            for (u32 i = 0; i < buf->len; i++) {
20000ac8:	e594361c 	ldr	r3, [r4, #1564]	; 0x61c
20000acc:	e3530000 	cmp	r3, #0
20000ad0:	0affffea 	beq	20000a80 <main+0x40>
20000ad4:	e244a001 	sub	sl, r4, #1
                kprint("{0:2:x} ", buf->buf[i]);
20000ad8:	e3019574 	movw	r9, #5492	; 0x1574
20000adc:	e3429000 	movt	r9, #8192	; 0x2000
20000ae0:	e1a0700a 	mov	r7, sl
20000ae4:	e5fa1001 	ldrb	r1, [sl, #1]!
20000ae8:	e1a00009 	mov	r0, r9
20000aec:	e12fff36 	blx	r6
            for (u32 i = 0; i < buf->len; i++) {
20000af0:	e2873002 	add	r3, r7, #2
20000af4:	e0433004 	sub	r3, r3, r4
20000af8:	e594261c 	ldr	r2, [r4, #1564]	; 0x61c
20000afc:	e1520003 	cmp	r2, r3
20000b00:	8afffff6 	bhi	20000ae0 <main+0xa0>
20000b04:	eaffffdd 	b	20000a80 <main+0x40>

20000b08 <kprint>:
#define KPRINT_BUF_SIZE 1024

static char kprint_buf[KPRINT_BUF_SIZE];
static char boot_message_buf[KPRINT_BUF_SIZE];

void kprint(const char* message, ...) {
20000b08:	e92d000f 	push	{r0, r1, r2, r3}
20000b0c:	e92d4030 	push	{r4, r5, lr}
20000b10:	e24dd00c 	sub	sp, sp, #12
    va_list arg;
    va_start(arg, message);
20000b14:	e28d301c 	add	r3, sp, #28
20000b18:	e58d3004 	str	r3, [sp, #4]
    u32 count =
        print_format_to_buf_arg(kprint_buf, KPRINT_BUF_SIZE, message, arg);
20000b1c:	e3014fc0 	movw	r4, #8128	; 0x1fc0
20000b20:	e3424000 	movt	r4, #8192	; 0x2000
20000b24:	e59d2018 	ldr	r2, [sp, #24]
20000b28:	e3a01b01 	mov	r1, #1024	; 0x400
20000b2c:	e1a00004 	mov	r0, r4
20000b30:	e300537c 	movw	r5, #892	; 0x37c
20000b34:	e3425000 	movt	r5, #8192	; 0x2000
20000b38:	e12fff35 	blx	r5
20000b3c:	e1a01000 	mov	r1, r0
    va_end(arg);

    kprint_from_buf(kprint_buf, count);
20000b40:	e1a00004 	mov	r0, r4
20000b44:	e3003d24 	movw	r3, #3364	; 0xd24
20000b48:	e3423000 	movt	r3, #8192	; 0x2000
20000b4c:	e12fff33 	blx	r3
}
20000b50:	e28dd00c 	add	sp, sp, #12
20000b54:	e8bd4030 	pop	{r4, r5, lr}
20000b58:	e28dd010 	add	sp, sp, #16
20000b5c:	e12fff1e 	bx	lr

20000b60 <boot_message>:

void boot_message(const char* message, ...) {
20000b60:	e92d000f 	push	{r0, r1, r2, r3}
20000b64:	e92d4030 	push	{r4, r5, lr}
20000b68:	e24dd00c 	sub	sp, sp, #12
    // Log any timestamps?
    
    va_list arg;
    va_start(arg, message);
20000b6c:	e28d301c 	add	r3, sp, #28
20000b70:	e58d3004 	str	r3, [sp, #4]
    u32 count =
        print_format_to_buf_arg(boot_message_buf, KPRINT_BUF_SIZE, message, arg);
20000b74:	e3014bc0 	movw	r4, #7104	; 0x1bc0
20000b78:	e3424000 	movt	r4, #8192	; 0x2000
20000b7c:	e59d2018 	ldr	r2, [sp, #24]
20000b80:	e3a01b01 	mov	r1, #1024	; 0x400
20000b84:	e1a00004 	mov	r0, r4
20000b88:	e300537c 	movw	r5, #892	; 0x37c
20000b8c:	e3425000 	movt	r5, #8192	; 0x2000
20000b90:	e12fff35 	blx	r5
20000b94:	e1a01000 	mov	r1, r0
    va_end(arg);

    kprint_from_buf(boot_message_buf, count);
20000b98:	e1a00004 	mov	r0, r4
20000b9c:	e3003d24 	movw	r3, #3364	; 0xd24
20000ba0:	e3423000 	movt	r3, #8192	; 0x2000
20000ba4:	e12fff33 	blx	r3
}
20000ba8:	e28dd00c 	add	sp, sp, #12
20000bac:	e8bd4030 	pop	{r4, r5, lr}
20000bb0:	e28dd010 	add	sp, sp, #16
20000bb4:	e12fff1e 	bx	lr

20000bb8 <panic>:
// Kernel panic implementation

#include <chaos/panic.h>
#include <chaos/kprint.h>

void panic(const char* message) {
20000bb8:	e92d4010 	push	{r4, lr}
20000bbc:	e1a01000 	mov	r1, r0
    kprint("Kernel panic!\n\t{s}\n", message);
20000bc0:	e3010584 	movw	r0, #5508	; 0x1584
20000bc4:	e3420000 	movt	r0, #8192	; 0x2000
20000bc8:	e3003b08 	movw	r3, #2824	; 0xb08
20000bcc:	e3423000 	movt	r3, #8192	; 0x2000
20000bd0:	e12fff33 	blx	r3
    while (1);
20000bd4:	eafffffe 	b	20000bd4 <panic+0x1c>

20000bd8 <assert_handler>:
// Kernel assert implementation

#include <chaos/assert.h>
#include <chaos/kprint.h>

void assert_handler(const char* file, u32 line) {
20000bd8:	e92d4010 	push	{r4, lr}
20000bdc:	e1a02001 	mov	r2, r1
    kprint("Kernel assert!\n\t{s}: {d}\n", file, line);
20000be0:	e1a01000 	mov	r1, r0
20000be4:	e3010598 	movw	r0, #5528	; 0x1598
20000be8:	e3420000 	movt	r0, #8192	; 0x2000
20000bec:	e3003b08 	movw	r3, #2824	; 0xb08
20000bf0:	e3423000 	movt	r3, #8192	; 0x2000
20000bf4:	e12fff33 	blx	r3
    while (1);
20000bf8:	eafffffe 	b	20000bf8 <assert_handler+0x20>

20000bfc <netbuf_init>:

// Allocate the netbuffers
static alignas(32) struct netbuf buffers[NIC_MAX_BUF];

// Initializes the netbuffers
void netbuf_init() {
20000bfc:	e92d4010 	push	{r4, lr}
#define list_get_struct(node, type, member) \
    (type *)((u8 *)node - offsetof(type, member))

// Initializes a list
static inline void list_init(struct list_node* list) {
    list->prev = list;
20000c00:	e30413c0 	movw	r1, #17344	; 0x43c0
20000c04:	e3421006 	movt	r1, #8198	; 0x2006
20000c08:	e5811004 	str	r1, [r1, #4]
    // Initialize the netbuffer pool
    list_init(&netbuf_pool);

    for (u32 i = 0; i < NIC_MAX_BUF; i++) {
20000c0c:	e59f3050 	ldr	r3, [pc, #80]	; 20000c64 <netbuf_init+0x68>
20000c10:	e283ca62 	add	ip, r3, #401408	; 0x62000
static inline void __list_add(struct list_node* new, struct list_node* prev,
    struct list_node* next) {
    prev->next = new;
    next->prev = new;
    new->next = next;
    new->prev = prev;
20000c14:	e1a00001 	mov	r0, r1
        list_push_front(&buffers[i].node, &netbuf_pool);
20000c18:	e1a02001 	mov	r2, r1
20000c1c:	e1a01003 	mov	r1, r3
    next->prev = new;
20000c20:	e5823004 	str	r3, [r2, #4]
    new->next = next;
20000c24:	e5832000 	str	r2, [r3]
    new->prev = prev;
20000c28:	e5830004 	str	r0, [r3, #4]
    for (u32 i = 0; i < NIC_MAX_BUF; i++) {
20000c2c:	e2833e62 	add	r3, r3, #1568	; 0x620
20000c30:	e153000c 	cmp	r3, ip
20000c34:	1afffff7 	bne	20000c18 <netbuf_init+0x1c>
20000c38:	e30433c0 	movw	r3, #17344	; 0x43c0
20000c3c:	e3423006 	movt	r3, #8198	; 0x2006
20000c40:	e59f2020 	ldr	r2, [pc, #32]	; 20000c68 <netbuf_init+0x6c>
20000c44:	e5832000 	str	r2, [r3]
    }

    kprint("Initialized {d} netbuffers\n", NIC_MAX_BUF);
20000c48:	e3a01c01 	mov	r1, #256	; 0x100
20000c4c:	e30105b4 	movw	r0, #5556	; 0x15b4
20000c50:	e3420000 	movt	r0, #8192	; 0x2000
20000c54:	e3003b08 	movw	r3, #2824	; 0xb08
20000c58:	e3423000 	movt	r3, #8192	; 0x2000
20000c5c:	e12fff33 	blx	r3
}
20000c60:	e8bd8010 	pop	{r4, pc}
20000c64:	200029d0 	.word	0x200029d0
20000c68:	200643b0 	.word	0x200643b0

20000c6c <alloc_netbuf>:
    node->prev = NULL;
}

// Deletes the first node in the list
static inline struct list_node* list_pop_front(struct list_node* list) {
    if (list->next == list) {
20000c6c:	e30433c0 	movw	r3, #17344	; 0x43c0
20000c70:	e3423006 	movt	r3, #8198	; 0x2006
20000c74:	e5930000 	ldr	r0, [r3]
20000c78:	e1500003 	cmp	r0, r3
20000c7c:	0a000008 	beq	20000ca4 <alloc_netbuf+0x38>
    __list_delete(node->prev, node->next);
20000c80:	e5902004 	ldr	r2, [r0, #4]
20000c84:	e5903000 	ldr	r3, [r0]
    prev->next = next;
20000c88:	e5823000 	str	r3, [r2]
    next->prev = prev;
20000c8c:	e5832004 	str	r2, [r3, #4]
    node->next = NULL;
20000c90:	e3a03000 	mov	r3, #0
20000c94:	e5803000 	str	r3, [r0]
    node->prev = NULL;
20000c98:	e5803004 	str	r3, [r0, #4]
    struct list_node* node = list_pop_front(&netbuf_pool);
    assert(node);

    // Convert the list node to a netbuf and return it
    return list_get_struct(node, struct netbuf, node);
}
20000c9c:	e2400e61 	sub	r0, r0, #1552	; 0x610
20000ca0:	e12fff1e 	bx	lr
struct netbuf* alloc_netbuf() {
20000ca4:	e92d4010 	push	{r4, lr}
    assert(node);
20000ca8:	e3a01020 	mov	r1, #32
20000cac:	e30105d0 	movw	r0, #5584	; 0x15d0
20000cb0:	e3420000 	movt	r0, #8192	; 0x2000
20000cb4:	e3003bd8 	movw	r3, #3032	; 0xbd8
20000cb8:	e3423000 	movt	r3, #8192	; 0x2000
20000cbc:	e12fff33 	blx	r3
20000cc0:	e3a00000 	mov	r0, #0
}
20000cc4:	e2400e61 	sub	r0, r0, #1552	; 0x610
20000cc8:	e8bd8010 	pop	{r4, pc}

20000ccc <free_netbuf>:

void free_netbuf(struct netbuf* buf) {
    // Get the first free netbuf list node
    list_push_back(&buf->node, &netbuf_pool);
20000ccc:	e2801e61 	add	r1, r0, #1552	; 0x610
    __list_add(new, list->prev, list);
20000cd0:	e30433c0 	movw	r3, #17344	; 0x43c0
20000cd4:	e3423006 	movt	r3, #8198	; 0x2006
20000cd8:	e5932004 	ldr	r2, [r3, #4]
    prev->next = new;
20000cdc:	e5821000 	str	r1, [r2]
    next->prev = new;
20000ce0:	e5831004 	str	r1, [r3, #4]
    new->next = next;
20000ce4:	e5803610 	str	r3, [r0, #1552]	; 0x610
    new->prev = prev;
20000ce8:	e5802614 	str	r2, [r0, #1556]	; 0x614
}
20000cec:	e12fff1e 	bx	lr

20000cf0 <network_start>:
#include <chaos/network.h>
#include <chaos/netbuf.h>
#include <chaos/kprint.h>
#include <chaos/nic.h>

void network_start() {
20000cf0:	e92d4010 	push	{r4, lr}

    kprint("Starting networking\n");
20000cf4:	e30105fc 	movw	r0, #5628	; 0x15fc
20000cf8:	e3420000 	movt	r0, #8192	; 0x2000
20000cfc:	e3003b08 	movw	r3, #2824	; 0xb08
20000d00:	e3423000 	movt	r3, #8192	; 0x2000
20000d04:	e12fff33 	blx	r3

    netbuf_init();
20000d08:	e3003bfc 	movw	r3, #3068	; 0xbfc
20000d0c:	e3423000 	movt	r3, #8192	; 0x2000
20000d10:	e12fff33 	blx	r3
    nic_init();
20000d14:	e3013410 	movw	r3, #5136	; 0x1410
20000d18:	e3423000 	movt	r3, #8192	; 0x2000
20000d1c:	e12fff33 	blx	r3
}
20000d20:	e8bd8010 	pop	{r4, pc}

20000d24 <kprint_from_buf>:
#include <sama5d2/regmap.h>

void kprint_from_buf(const char* buf, u32 size) {
    struct uart_reg* const hw = UART1_REG;

    while (size--) {
20000d24:	e3510000 	cmp	r1, #0
20000d28:	012fff1e 	bxeq	lr
void kprint_from_buf(const char* buf, u32 size) {
20000d2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
20000d30:	e241c001 	sub	ip, r1, #1
20000d34:	e2401001 	sub	r1, r0, #1
20000d38:	e080c00c 	add	ip, r0, ip
        // Make sure we terminatie the line with CR-LF
        if (*buf == '\n') {
            while (!(hw->sr & (1 << 1)));
20000d3c:	e3a02000 	mov	r2, #0
20000d40:	e34f2802 	movt	r2, #63490	; 0xf802
            hw->thr = '\r';
20000d44:	e3a0e00d 	mov	lr, #13
20000d48:	ea000006 	b	20000d68 <kprint_from_buf+0x44>
        }
        while (!(hw->sr & (1 << 1)));
20000d4c:	e5923014 	ldr	r3, [r2, #20]
20000d50:	e3130002 	tst	r3, #2
20000d54:	0afffffc 	beq	20000d4c <kprint_from_buf+0x28>
        hw->thr = *buf++;
20000d58:	e5d03000 	ldrb	r3, [r0]
20000d5c:	e582301c 	str	r3, [r2, #28]
    while (size--) {
20000d60:	e151000c 	cmp	r1, ip
20000d64:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
        if (*buf == '\n') {
20000d68:	e2811001 	add	r1, r1, #1
20000d6c:	e1a00001 	mov	r0, r1
20000d70:	e5d13000 	ldrb	r3, [r1]
20000d74:	e353000a 	cmp	r3, #10
20000d78:	1afffff3 	bne	20000d4c <kprint_from_buf+0x28>
            while (!(hw->sr & (1 << 1)));
20000d7c:	e5923014 	ldr	r3, [r2, #20]
20000d80:	e3130002 	tst	r3, #2
20000d84:	0afffffc 	beq	20000d7c <kprint_from_buf+0x58>
            hw->thr = '\r';
20000d88:	e582e01c 	str	lr, [r2, #28]
20000d8c:	eaffffee 	b	20000d4c <kprint_from_buf+0x28>

20000d90 <sama5d2_gpio_set_func>:
// // GPIO kernel driver for the SAMA5D2 chip

#include <sama5d2/sama5d2_gpio.h>
#include <chaos/assert.h>

void sama5d2_gpio_set_func(struct gpio_reg* hw, u32 pin, enum gpio_func func) {
20000d90:	e92d4070 	push	{r4, r5, r6, lr}
20000d94:	e1a04000 	mov	r4, r0
20000d98:	e1a05001 	mov	r5, r1
20000d9c:	e1a06002 	mov	r6, r2
    assert(pin < 32);
20000da0:	e351001f 	cmp	r1, #31
20000da4:	8a000004 	bhi	20000dbc <sama5d2_gpio_set_func+0x2c>

    hw->mskr = (1 << pin);
20000da8:	e3a01001 	mov	r1, #1
20000dac:	e1a05511 	lsl	r5, r1, r5
20000db0:	e5845000 	str	r5, [r4]
    hw->cfgr = func;
20000db4:	e5846004 	str	r6, [r4, #4]
}
20000db8:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(pin < 32);
20000dbc:	e3a01007 	mov	r1, #7
20000dc0:	e3010614 	movw	r0, #5652	; 0x1614
20000dc4:	e3420000 	movt	r0, #8192	; 0x2000
20000dc8:	e3003bd8 	movw	r3, #3032	; 0xbd8
20000dcc:	e3423000 	movt	r3, #8192	; 0x2000
20000dd0:	e12fff33 	blx	r3
20000dd4:	eafffff3 	b	20000da8 <sama5d2_gpio_set_func+0x18>

20000dd8 <sama5d2_per_clk_en>:
#include <chaos/assert.h>

// These functions takes in PID numbers defined in the Periheral chapter in the
// datasheet (SAMA5D2 page 57)

void sama5d2_per_clk_en(u32 pid) {
20000dd8:	e92d4010 	push	{r4, lr}
20000ddc:	e1a04000 	mov	r4, r0
    assert(pid >= 2 && pid < 64);
20000de0:	e2403002 	sub	r3, r0, #2
20000de4:	e353003d 	cmp	r3, #61	; 0x3d
20000de8:	8a000007 	bhi	20000e0c <sama5d2_per_clk_en+0x34>

    // Get a pointer to the hardware
    struct pmc_reg* hw = PMC_REG;

    if (pid < 32) {
20000dec:	e354001f 	cmp	r4, #31
20000df0:	8a00000c 	bhi	20000e28 <sama5d2_per_clk_en+0x50>
        hw->pcer0 = (1 << pid);
20000df4:	e3a00001 	mov	r0, #1
20000df8:	e1a04410 	lsl	r4, r0, r4
20000dfc:	e3a03901 	mov	r3, #16384	; 0x4000
20000e00:	e34f3001 	movt	r3, #61441	; 0xf001
20000e04:	e5834010 	str	r4, [r3, #16]
20000e08:	e8bd8010 	pop	{r4, pc}
    assert(pid >= 2 && pid < 64);
20000e0c:	e3a0100b 	mov	r1, #11
20000e10:	e3010648 	movw	r0, #5704	; 0x1648
20000e14:	e3420000 	movt	r0, #8192	; 0x2000
20000e18:	e3003bd8 	movw	r3, #3032	; 0xbd8
20000e1c:	e3423000 	movt	r3, #8192	; 0x2000
20000e20:	e12fff33 	blx	r3
20000e24:	eafffff0 	b	20000dec <sama5d2_per_clk_en+0x14>
    } else {
        pid -= 32;
20000e28:	e2444020 	sub	r4, r4, #32
        hw->pcer1 = (1 << pid);
20000e2c:	e3a00001 	mov	r0, #1
20000e30:	e1a04410 	lsl	r4, r0, r4
20000e34:	e3a03901 	mov	r3, #16384	; 0x4000
20000e38:	e34f3001 	movt	r3, #61441	; 0xf001
20000e3c:	e5834100 	str	r4, [r3, #256]	; 0x100
    }
}
20000e40:	e8bd8010 	pop	{r4, pc}

20000e44 <nic_setup_dma_queues>:
};

// Configures all the NIC queues (rings). This will allocate a netbuf for each DMA 
// descriptor and link the DMA descriptor to the netbuf->buf. This also configures the 
// hardware registers for each queue
void nic_setup_dma_queues() {
20000e44:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
20000e48:	e24dd014 	sub	sp, sp, #20
    for (u32 i = 0; i < NIC_QUEUES; i++) {
20000e4c:	e3013728 	movw	r3, #5928	; 0x1728
20000e50:	e3423000 	movt	r3, #8192	; 0x2000
20000e54:	e58d3000 	str	r3, [sp]
        const struct netbuf* netbuf;
        const struct nic_queue* queue = &queues[i];

        // Configure the TX queue
        for (u32 j = 0; j < queue->tx_count; j++) {
            netbuf = alloc_netbuf();
20000e58:	e300ac6c 	movw	sl, #3180	; 0xc6c
20000e5c:	e342a000 	movt	sl, #8192	; 0x2000
            struct nic_tx_desc* tx = &queue->tx[j];

            // Link the descriptor to the netbuf
            // TODO: when the MMU is on we must convert to physical address
            tx->status_word = 0;
20000e60:	e3a08000 	mov	r8, #0
            netbuf = alloc_netbuf();
            struct nic_rx_desc* rx = &queue->rx[j];

            // Link the descriptor to the netbuf
            // TODO: when the MMU is on we must convert to physical address
            assert(((u32)netbuf & 0b11) == 0);
20000e64:	e3003bd8 	movw	r3, #3032	; 0xbd8
20000e68:	e3423000 	movt	r3, #8192	; 0x2000
20000e6c:	e58d3004 	str	r3, [sp, #4]
20000e70:	e301367c 	movw	r3, #5756	; 0x167c
20000e74:	e3423000 	movt	r3, #8192	; 0x2000
20000e78:	e58d3008 	str	r3, [sp, #8]
20000e7c:	ea000026 	b	20000f1c <nic_setup_dma_queues+0xd8>
20000e80:	e3a010b6 	mov	r1, #182	; 0xb6
20000e84:	e59d0008 	ldr	r0, [sp, #8]
20000e88:	e59d3004 	ldr	r3, [sp, #4]
20000e8c:	e12fff33 	blx	r3

            rx->addr_word = 0;
            rx->status_word = 0;
20000e90:	e5858004 	str	r8, [r5, #4]

            // The address is in bits 32..2
            rx->addr = (u32)netbuf >> 2;
20000e94:	e1a04124 	lsr	r4, r4, #2
20000e98:	e1a03008 	mov	r3, r8
20000e9c:	e7df3114 	bfi	r3, r4, #2, #30
20000ea0:	e5853000 	str	r3, [r5]
        for (u32 j = 0; j < queue->rx_count; j++) {
20000ea4:	e2877001 	add	r7, r7, #1
20000ea8:	e2866014 	add	r6, r6, #20
20000eac:	e157000b 	cmp	r7, fp
20000eb0:	0a000006 	beq	20000ed0 <nic_setup_dma_queues+0x8c>
            netbuf = alloc_netbuf();
20000eb4:	e12fff3a 	blx	sl
20000eb8:	e1a04000 	mov	r4, r0
            struct nic_rx_desc* rx = &queue->rx[j];
20000ebc:	e5995000 	ldr	r5, [r9]
20000ec0:	e0855006 	add	r5, r5, r6
            assert(((u32)netbuf & 0b11) == 0);
20000ec4:	e3100003 	tst	r0, #3
20000ec8:	0afffff0 	beq	20000e90 <nic_setup_dma_queues+0x4c>
20000ecc:	eaffffeb 	b	20000e80 <nic_setup_dma_queues+0x3c>
        }

        // Mark the end descriptor with the wrap bit, causing the DMA to fetch the base
        // descriptor on the next read
        queue->rx[queue->rx_count - 1].wrap = 1;
20000ed0:	e5993000 	ldr	r3, [r9]
20000ed4:	e3a02014 	mov	r2, #20
20000ed8:	e02b3b92 	mla	fp, r2, fp, r3
20000edc:	e55b3014 	ldrb	r3, [fp, #-20]	; 0xffffffec
20000ee0:	e3833002 	orr	r3, r3, #2
20000ee4:	e54b3014 	strb	r3, [fp, #-20]	; 0xffffffec
        queue->tx[queue->tx_count - 1].wrap = 1;
20000ee8:	e59d300c 	ldr	r3, [sp, #12]
20000eec:	e243221e 	sub	r2, r3, #-536870911	; 0xe0000001
20000ef0:	e5993004 	ldr	r3, [r9, #4]
20000ef4:	e0833182 	add	r3, r3, r2, lsl #3
20000ef8:	e5d32007 	ldrb	r2, [r3, #7]
20000efc:	e3822040 	orr	r2, r2, #64	; 0x40
20000f00:	e5c32007 	strb	r2, [r3, #7]
    for (u32 i = 0; i < NIC_QUEUES; i++) {
20000f04:	e59d3000 	ldr	r3, [sp]
20000f08:	e2833010 	add	r3, r3, #16
20000f0c:	e58d3000 	str	r3, [sp]
20000f10:	e59f20cc 	ldr	r2, [pc, #204]	; 20000fe4 <nic_setup_dma_queues+0x1a0>
20000f14:	e1530002 	cmp	r3, r2
20000f18:	0a000017 	beq	20000f7c <nic_setup_dma_queues+0x138>
        for (u32 j = 0; j < queue->tx_count; j++) {
20000f1c:	e59d3000 	ldr	r3, [sp]
20000f20:	e1a09003 	mov	r9, r3
20000f24:	e5933008 	ldr	r3, [r3, #8]
20000f28:	e58d300c 	str	r3, [sp, #12]
20000f2c:	e3530000 	cmp	r3, #0
20000f30:	13a04000 	movne	r4, #0
20000f34:	159d500c 	ldrne	r5, [sp, #12]
20000f38:	0a000009 	beq	20000f64 <nic_setup_dma_queues+0x120>
            netbuf = alloc_netbuf();
20000f3c:	e12fff3a 	blx	sl
            struct nic_tx_desc* tx = &queue->tx[j];
20000f40:	e5992004 	ldr	r2, [r9, #4]
20000f44:	e0823184 	add	r3, r2, r4, lsl #3
            tx->status_word = 0;
20000f48:	e5838004 	str	r8, [r3, #4]
            tx->addr = (u32)netbuf;
20000f4c:	e7820184 	str	r0, [r2, r4, lsl #3]
            tx->used = 1;
20000f50:	e3a02080 	mov	r2, #128	; 0x80
20000f54:	e5c32007 	strb	r2, [r3, #7]
        for (u32 j = 0; j < queue->tx_count; j++) {
20000f58:	e2844001 	add	r4, r4, #1
20000f5c:	e1540005 	cmp	r4, r5
20000f60:	1afffff5 	bne	20000f3c <nic_setup_dma_queues+0xf8>
        for (u32 j = 0; j < queue->rx_count; j++) {
20000f64:	e599b00c 	ldr	fp, [r9, #12]
20000f68:	e35b0000 	cmp	fp, #0
20000f6c:	0affffd7 	beq	20000ed0 <nic_setup_dma_queues+0x8c>
20000f70:	e3a06000 	mov	r6, #0
20000f74:	e1a07006 	mov	r7, r6
20000f78:	eaffffcd 	b	20000eb4 <nic_setup_dma_queues+0x70>
    }

    // Map in the queues in the NIC hardware
    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->rbqb       = (u32)rx_descs;
20000f7c:	e3042400 	movw	r2, #17408	; 0x4400
20000f80:	e3422006 	movt	r2, #8198	; 0x2006
20000f84:	e3a03902 	mov	r3, #32768	; 0x8000
20000f88:	e34f3800 	movt	r3, #63488	; 0xf800
20000f8c:	e5832018 	str	r2, [r3, #24]
    nic_reg->tbqb       = (u32)tx_descs;
20000f90:	e3042bc0 	movw	r2, #19392	; 0x4bc0
20000f94:	e3422006 	movt	r2, #8198	; 0x2006
20000f98:	e583201c 	str	r2, [r3, #28]
    nic_reg->rbqbapq[0] = (u32)rx_descs_q1;
20000f9c:	e3042680 	movw	r2, #18048	; 0x4680
20000fa0:	e3422006 	movt	r2, #8198	; 0x2006
20000fa4:	e583247c 	str	r2, [r3, #1148]	; 0x47c
    nic_reg->tbqbapq[0] = (u32)tx_descs_q1;
20000fa8:	e3042cc0 	movw	r2, #19648	; 0x4cc0
20000fac:	e3422006 	movt	r2, #8198	; 0x2006
20000fb0:	e583243c 	str	r2, [r3, #1084]	; 0x43c
    nic_reg->rbqbapq[1] = (u32)rx_descs_q2;
20000fb4:	e3042900 	movw	r2, #18688	; 0x4900
20000fb8:	e3422006 	movt	r2, #8198	; 0x2006
20000fbc:	e5832480 	str	r2, [r3, #1152]	; 0x480
    nic_reg->tbqbapq[1] = (u32)tx_descs_q2;
20000fc0:	e3042dc0 	movw	r2, #19904	; 0x4dc0
20000fc4:	e3422006 	movt	r2, #8198	; 0x2006
20000fc8:	e5832440 	str	r2, [r3, #1088]	; 0x440

    // Make sure we start reading from the base descriptor
    rx_index = 0;
20000fcc:	e3043b80 	movw	r3, #19328	; 0x4b80
20000fd0:	e3423006 	movt	r3, #8198	; 0x2006
20000fd4:	e3a02000 	mov	r2, #0
20000fd8:	e5832000 	str	r2, [r3]
    tx_index = 0;
}
20000fdc:	e28dd014 	add	sp, sp, #20
20000fe0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
20000fe4:	20001758 	.word	0x20001758

20000fe8 <ethernet_phy_read>:

// Reads a 16-bit register from the addressed ethernet PHY. Both the register address and 
// the etnernet PHY address should be in range 0..31
u16 ethernet_phy_read(u8 phy, u8 reg) {
20000fe8:	e92d4070 	push	{r4, r5, r6, lr}
20000fec:	e1a05000 	mov	r5, r0
20000ff0:	e1a04001 	mov	r4, r1
    assert(phy < 32);
20000ff4:	e350001f 	cmp	r0, #31
20000ff8:	8a000012 	bhi	20001048 <ethernet_phy_read+0x60>
    assert(reg < 32);
20000ffc:	e354001f 	cmp	r4, #31
20001000:	8a000017 	bhi	20001064 <ethernet_phy_read+0x7c>
    
    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->man = (1 << 30) | (1 << 29) | (1 << 17) | (phy << 23) | (reg << 18);
20001004:	e1a03904 	lsl	r3, r4, #18
20001008:	e1833b85 	orr	r3, r3, r5, lsl #23
2000100c:	e3833206 	orr	r3, r3, #1610612736	; 0x60000000
20001010:	e3833802 	orr	r3, r3, #131072	; 0x20000
20001014:	e3a02902 	mov	r2, #32768	; 0x8000
20001018:	e34f2800 	movt	r2, #63488	; 0xf800
2000101c:	e5823034 	str	r3, [r2, #52]	; 0x34
    while ((nic_reg->nsr & (1 << 2)) == 0);
20001020:	e3a02902 	mov	r2, #32768	; 0x8000
20001024:	e34f2800 	movt	r2, #63488	; 0xf800
20001028:	e5923008 	ldr	r3, [r2, #8]
2000102c:	e3130004 	tst	r3, #4
20001030:	0afffffc 	beq	20001028 <ethernet_phy_read+0x40>

    return (u16)nic_reg->man;
20001034:	e3a03902 	mov	r3, #32768	; 0x8000
20001038:	e34f3800 	movt	r3, #63488	; 0xf800
2000103c:	e5930034 	ldr	r0, [r3, #52]	; 0x34
}
20001040:	e6ff0070 	uxth	r0, r0
20001044:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(phy < 32);
20001048:	e3a010d7 	mov	r1, #215	; 0xd7
2000104c:	e301067c 	movw	r0, #5756	; 0x167c
20001050:	e3420000 	movt	r0, #8192	; 0x2000
20001054:	e3003bd8 	movw	r3, #3032	; 0xbd8
20001058:	e3423000 	movt	r3, #8192	; 0x2000
2000105c:	e12fff33 	blx	r3
20001060:	eaffffe5 	b	20000ffc <ethernet_phy_read+0x14>
    assert(reg < 32);
20001064:	e3a010d8 	mov	r1, #216	; 0xd8
20001068:	e301067c 	movw	r0, #5756	; 0x167c
2000106c:	e3420000 	movt	r0, #8192	; 0x2000
20001070:	e3003bd8 	movw	r3, #3032	; 0xbd8
20001074:	e3423000 	movt	r3, #8192	; 0x2000
20001078:	e12fff33 	blx	r3
2000107c:	eaffffe0 	b	20001004 <ethernet_phy_read+0x1c>

20001080 <ethernet_phy_write>:

// Writes a 16-bit register to the address ethernet PHY. Both the register address and 
// the etnernet PHY address should be in range 0..31
void ethernet_phy_write(u8 phy, u8 reg, u16 val) {
20001080:	e92d4070 	push	{r4, r5, r6, lr}
20001084:	e1a06000 	mov	r6, r0
20001088:	e1a05001 	mov	r5, r1
2000108c:	e1a04002 	mov	r4, r2
    assert(phy < 32);
20001090:	e350001f 	cmp	r0, #31
20001094:	8a00000e 	bhi	200010d4 <ethernet_phy_write+0x54>
    assert(reg < 32);
20001098:	e355001f 	cmp	r5, #31
2000109c:	8a000013 	bhi	200010f0 <ethernet_phy_write+0x70>

    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->man = (1 << 30) | (1 << 28) | (1 << 17) | (phy << 23) | (reg << 18) | val;
200010a0:	e1843b86 	orr	r3, r4, r6, lsl #23
200010a4:	e1833905 	orr	r3, r3, r5, lsl #18
200010a8:	e3833205 	orr	r3, r3, #1342177280	; 0x50000000
200010ac:	e3833802 	orr	r3, r3, #131072	; 0x20000
200010b0:	e3a02902 	mov	r2, #32768	; 0x8000
200010b4:	e34f2800 	movt	r2, #63488	; 0xf800
200010b8:	e5823034 	str	r3, [r2, #52]	; 0x34
    while ((nic_reg->nsr & (1 << 2)) == 0);
200010bc:	e3a02902 	mov	r2, #32768	; 0x8000
200010c0:	e34f2800 	movt	r2, #63488	; 0xf800
200010c4:	e5923008 	ldr	r3, [r2, #8]
200010c8:	e3130004 	tst	r3, #4
200010cc:	0afffffc 	beq	200010c4 <ethernet_phy_write+0x44>
200010d0:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(phy < 32);
200010d4:	e3a010e5 	mov	r1, #229	; 0xe5
200010d8:	e301067c 	movw	r0, #5756	; 0x167c
200010dc:	e3420000 	movt	r0, #8192	; 0x2000
200010e0:	e3003bd8 	movw	r3, #3032	; 0xbd8
200010e4:	e3423000 	movt	r3, #8192	; 0x2000
200010e8:	e12fff33 	blx	r3
200010ec:	eaffffe9 	b	20001098 <ethernet_phy_write+0x18>
    assert(reg < 32);
200010f0:	e3a010e6 	mov	r1, #230	; 0xe6
200010f4:	e301067c 	movw	r0, #5756	; 0x167c
200010f8:	e3420000 	movt	r0, #8192	; 0x2000
200010fc:	e3003bd8 	movw	r3, #3032	; 0xbd8
20001100:	e3423000 	movt	r3, #8192	; 0x2000
20001104:	e12fff33 	blx	r3
20001108:	eaffffe4 	b	200010a0 <ethernet_phy_write+0x20>

2000110c <ethernet_phy_scan>:
}

// Performs a scan after available ethernet PHYs and return the address of the first 
// responding PHY
u8 ethernet_phy_scan() {
2000110c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    for (u32 i = 0; i < 32; i++) {
20001110:	e3a04000 	mov	r4, #0

        // Read the PHY ID reg
        if (ethernet_phy_read(i, 2) != 0xFFFF) {
20001114:	e3a08002 	mov	r8, #2
20001118:	e3006fe8 	movw	r6, #4072	; 0xfe8
2000111c:	e3426000 	movt	r6, #8192	; 0x2000
20001120:	e30f7fff 	movw	r7, #65535	; 0xffff
20001124:	e6ef5074 	uxtb	r5, r4
20001128:	e1a01008 	mov	r1, r8
2000112c:	e1a00005 	mov	r0, r5
20001130:	e12fff36 	blx	r6
20001134:	e1500007 	cmp	r0, r7
20001138:	1a000008 	bne	20001160 <ethernet_phy_scan+0x54>
    for (u32 i = 0; i < 32; i++) {
2000113c:	e2844001 	add	r4, r4, #1
20001140:	e3540020 	cmp	r4, #32
20001144:	1afffff6 	bne	20001124 <ethernet_phy_scan+0x18>
            return i;
        }
    }
    panic("No phy\n");
20001148:	e30106b0 	movw	r0, #5808	; 0x16b0
2000114c:	e3420000 	movt	r0, #8192	; 0x2000
20001150:	e3003bb8 	movw	r3, #3000	; 0xbb8
20001154:	e3423000 	movt	r3, #8192	; 0x2000
20001158:	e12fff33 	blx	r3
    return 0;
2000115c:	e3a05000 	mov	r5, #0
}
20001160:	e1a00005 	mov	r0, r5
20001164:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

20001168 <phy_establish_link>:

// Configures the ethernet PHY for full-duplex, 100 Mbps opration and returns when the 
// auto-negotiation is complete and the link is up 
void phy_establish_link(u8 addr) {
20001168:	e92d4070 	push	{r4, r5, r6, lr}
2000116c:	e1a04000 	mov	r4, r0
    // Check if the link is already up
    if ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0) {
20001170:	e3a01001 	mov	r1, #1
20001174:	e3003fe8 	movw	r3, #4072	; 0xfe8
20001178:	e3423000 	movt	r3, #8192	; 0x2000
2000117c:	e12fff33 	blx	r3
20001180:	e3100020 	tst	r0, #32
20001184:	0a000008 	beq	200011ac <phy_establish_link+0x44>
        ethernet_phy_write(addr, 0, ethernet_phy_read(addr, 0) | (1 << 9));
        while ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0);
    }

    // Wait for the link-up status
    while ((ethernet_phy_read(addr, 1) & (1 << 2)) == 0);
20001188:	e3a06001 	mov	r6, #1
2000118c:	e3005fe8 	movw	r5, #4072	; 0xfe8
20001190:	e3425000 	movt	r5, #8192	; 0x2000
20001194:	e1a01006 	mov	r1, r6
20001198:	e1a00004 	mov	r0, r4
2000119c:	e12fff35 	blx	r5
200011a0:	e3100004 	tst	r0, #4
200011a4:	0afffffa 	beq	20001194 <phy_establish_link+0x2c>
200011a8:	e8bd8070 	pop	{r4, r5, r6, pc}
        ethernet_phy_write(addr, 4, ethernet_phy_read(addr, 4) | (0b1111 << 5));
200011ac:	e3a01004 	mov	r1, #4
200011b0:	e1a00004 	mov	r0, r4
200011b4:	e3006fe8 	movw	r6, #4072	; 0xfe8
200011b8:	e3426000 	movt	r6, #8192	; 0x2000
200011bc:	e12fff36 	blx	r6
200011c0:	e3802e1e 	orr	r2, r0, #480	; 0x1e0
200011c4:	e6ff2072 	uxth	r2, r2
200011c8:	e3a01004 	mov	r1, #4
200011cc:	e1a00004 	mov	r0, r4
200011d0:	e3015080 	movw	r5, #4224	; 0x1080
200011d4:	e3425000 	movt	r5, #8192	; 0x2000
200011d8:	e12fff35 	blx	r5
        ethernet_phy_write(addr, 0, ethernet_phy_read(addr, 0) | (1 << 9));
200011dc:	e3a01000 	mov	r1, #0
200011e0:	e1a00004 	mov	r0, r4
200011e4:	e12fff36 	blx	r6
200011e8:	e3802c02 	orr	r2, r0, #512	; 0x200
200011ec:	e6ff2072 	uxth	r2, r2
200011f0:	e3a01000 	mov	r1, #0
200011f4:	e1a00004 	mov	r0, r4
200011f8:	e12fff35 	blx	r5
        while ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0);
200011fc:	e3a06001 	mov	r6, #1
20001200:	e3005fe8 	movw	r5, #4072	; 0xfe8
20001204:	e3425000 	movt	r5, #8192	; 0x2000
20001208:	e1a01006 	mov	r1, r6
2000120c:	e1a00004 	mov	r0, r4
20001210:	e12fff35 	blx	r5
20001214:	e3100020 	tst	r0, #32
20001218:	0afffffa 	beq	20001208 <phy_establish_link+0xa0>
2000121c:	eaffffd9 	b	20001188 <phy_establish_link+0x20>

20001220 <get_phy_settings>:
}

// Get the speed and duplex setting from the link partner
void get_phy_settings(u8 addr, struct nic_link_setting* link_setting) {
20001220:	e92d4010 	push	{r4, lr}
20001224:	e1a04001 	mov	r4, r1
    // Read the link partner status register
    u16 reg = ethernet_phy_read(addr, 5);
20001228:	e3a01005 	mov	r1, #5
2000122c:	e3003fe8 	movw	r3, #4072	; 0xfe8
20001230:	e3423000 	movt	r3, #8192	; 0x2000
20001234:	e12fff33 	blx	r3

    if (reg & (0b11 << 7)) {
20001238:	e3100d06 	tst	r0, #384	; 0x180
        link_setting->speed = NIC_100Mbps;
2000123c:	13a03000 	movne	r3, #0
20001240:	15c43000 	strbne	r3, [r4]
        link_setting->duplex = (reg & (1 << 8)) ? NIC_DUPLEX_FULL : NIC_DUPLEX_HALF;
20001244:	12200c01 	eorne	r0, r0, #256	; 0x100
20001248:	17e00450 	ubfxne	r0, r0, #8, #1
    } else {
        link_setting->speed = NIC_10Mbps;
2000124c:	03a03001 	moveq	r3, #1
20001250:	05c43000 	strbeq	r3, [r4]
        link_setting->duplex = (reg & (1 << 6)) ? NIC_DUPLEX_FULL : NIC_DUPLEX_HALF;
20001254:	02200040 	eoreq	r0, r0, #64	; 0x40
20001258:	07e00350 	ubfxeq	r0, r0, #6, #1
2000125c:	e5c40001 	strb	r0, [r4, #1]
    }
}
20001260:	e8bd8010 	pop	{r4, pc}

20001264 <nic_pin_init>:

// Configure the NIC pins
void nic_pin_init() {
20001264:	e92d4070 	push	{r4, r5, r6, lr}
    sama5d2_gpio_set_func(GPIOD_REG,  9, GPIO_FUNC_D);
20001268:	e30850c0 	movw	r5, #32960	; 0x80c0
2000126c:	e34f5c03 	movt	r5, #64515	; 0xfc03
20001270:	e3a02004 	mov	r2, #4
20001274:	e3a01009 	mov	r1, #9
20001278:	e1a00005 	mov	r0, r5
2000127c:	e3004d90 	movw	r4, #3472	; 0xd90
20001280:	e3424000 	movt	r4, #8192	; 0x2000
20001284:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 10, GPIO_FUNC_D);
20001288:	e3a02004 	mov	r2, #4
2000128c:	e3a0100a 	mov	r1, #10
20001290:	e1a00005 	mov	r0, r5
20001294:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 11, GPIO_FUNC_D);
20001298:	e3a02004 	mov	r2, #4
2000129c:	e3a0100b 	mov	r1, #11
200012a0:	e1a00005 	mov	r0, r5
200012a4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 12, GPIO_FUNC_D);
200012a8:	e3a02004 	mov	r2, #4
200012ac:	e3a0100c 	mov	r1, #12
200012b0:	e1a00005 	mov	r0, r5
200012b4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 13, GPIO_FUNC_D);
200012b8:	e3a02004 	mov	r2, #4
200012bc:	e3a0100d 	mov	r1, #13
200012c0:	e1a00005 	mov	r0, r5
200012c4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 14, GPIO_FUNC_D);
200012c8:	e3a02004 	mov	r2, #4
200012cc:	e3a0100e 	mov	r1, #14
200012d0:	e1a00005 	mov	r0, r5
200012d4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 15, GPIO_FUNC_D);
200012d8:	e3a02004 	mov	r2, #4
200012dc:	e3a0100f 	mov	r1, #15
200012e0:	e1a00005 	mov	r0, r5
200012e4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 16, GPIO_FUNC_D);
200012e8:	e3a02004 	mov	r2, #4
200012ec:	e3a01010 	mov	r1, #16
200012f0:	e1a00005 	mov	r0, r5
200012f4:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 17, GPIO_FUNC_D);
200012f8:	e3a02004 	mov	r2, #4
200012fc:	e3a01011 	mov	r1, #17
20001300:	e1a00005 	mov	r0, r5
20001304:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 18, GPIO_FUNC_D);
20001308:	e3a02004 	mov	r2, #4
2000130c:	e3a01012 	mov	r1, #18
20001310:	e1a00005 	mov	r0, r5
20001314:	e12fff34 	blx	r4
}
20001318:	e8bd8070 	pop	{r4, r5, r6, pc}

2000131c <nic_receive>:

// Tries to receive a IEEE 802.3 ethernet packet from the NIC hardware. This will either
// return a netbuf with the packet data, or NULL. The netbuf will be completely unlinked 
// adfter this call, so the user must free the netbuf manually when done reading 
struct netbuf* nic_receive() {
2000131c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    struct nic_rx_desc* rx_desc = &rx_descs[rx_index];
20001320:	e3043b80 	movw	r3, #19328	; 0x4b80
20001324:	e3423006 	movt	r3, #8198	; 0x2006
20001328:	e5935000 	ldr	r5, [r3]

    if (rx_desc->owner) {
2000132c:	e3042400 	movw	r2, #17408	; 0x4400
20001330:	e3422006 	movt	r2, #8198	; 0x2006
20001334:	e3a03014 	mov	r3, #20
20001338:	e0030593 	mul	r3, r3, r5
2000133c:	e7d23003 	ldrb	r3, [r2, r3]
20001340:	e3130001 	tst	r3, #1
        // TODO: invalidate the cache before returning !!!!!!!!!!
        return netbuf;
    }

    // Any error handling?
    return NULL;
20001344:	03a04000 	moveq	r4, #0
    if (rx_desc->owner) {
20001348:	0a000027 	beq	200013ec <nic_receive+0xd0>
        struct netbuf* netbuf = (struct netbuf *)(rx_desc->addr << 2);
2000134c:	e3042400 	movw	r2, #17408	; 0x4400
20001350:	e3422006 	movt	r2, #8198	; 0x2006
20001354:	e3a03014 	mov	r3, #20
20001358:	e0030593 	mul	r3, r3, r5
2000135c:	e7924003 	ldr	r4, [r2, r3]
20001360:	e3c44003 	bic	r4, r4, #3
        if (++rx_index >= NIC_NUM_RX_DESC) {
20001364:	e2853001 	add	r3, r5, #1
20001368:	e353001f 	cmp	r3, #31
2000136c:	93042b80 	movwls	r2, #19328	; 0x4b80
20001370:	93422006 	movtls	r2, #8198	; 0x2006
20001374:	95823000 	strls	r3, [r2]
            rx_index = 0;
20001378:	83043b80 	movwhi	r3, #19328	; 0x4b80
2000137c:	83423006 	movthi	r3, #8198	; 0x2006
20001380:	83a02000 	movhi	r2, #0
20001384:	85832000 	strhi	r2, [r3]
        assert(rx_desc->sof && rx_desc->eof);
20001388:	e3042400 	movw	r2, #17408	; 0x4400
2000138c:	e3422006 	movt	r2, #8198	; 0x2006
20001390:	e3a03014 	mov	r3, #20
20001394:	e0232593 	mla	r3, r3, r5, r2
20001398:	e5d33005 	ldrb	r3, [r3, #5]
2000139c:	e20330c0 	and	r3, r3, #192	; 0xc0
200013a0:	e35300c0 	cmp	r3, #192	; 0xc0
200013a4:	1a000012 	bne	200013f4 <nic_receive+0xd8>
        netbuf->len = rx_desc->len;
200013a8:	e3046400 	movw	r6, #17408	; 0x4400
200013ac:	e3426006 	movt	r6, #8198	; 0x2006
200013b0:	e3a03014 	mov	r3, #20
200013b4:	e0050593 	mul	r5, r3, r5
200013b8:	e0867005 	add	r7, r6, r5
200013bc:	e1d730b4 	ldrh	r3, [r7, #4]
200013c0:	e7ec3053 	ubfx	r3, r3, #0, #13
200013c4:	e584361c 	str	r3, [r4, #1564]	; 0x61c
        netbuf->ptr = netbuf->buf;
200013c8:	e5844618 	str	r4, [r4, #1560]	; 0x618
        struct netbuf* new = alloc_netbuf();
200013cc:	e3003c6c 	movw	r3, #3180	; 0xc6c
200013d0:	e3423000 	movt	r3, #8192	; 0x2000
200013d4:	e12fff33 	blx	r3
        rx_desc->addr_word = 0;
200013d8:	e3a03000 	mov	r3, #0
        rx_desc->status_word = 0;
200013dc:	e5873004 	str	r3, [r7, #4]
        rx_desc->addr = (u32)new->buf >> 2;
200013e0:	e1a00120 	lsr	r0, r0, #2
200013e4:	e7df3110 	bfi	r3, r0, #2, #30
200013e8:	e7863005 	str	r3, [r6, r5]
}
200013ec:	e1a00004 	mov	r0, r4
200013f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        assert(rx_desc->sof && rx_desc->eof);
200013f4:	e3001139 	movw	r1, #313	; 0x139
200013f8:	e301067c 	movw	r0, #5756	; 0x167c
200013fc:	e3420000 	movt	r0, #8192	; 0x2000
20001400:	e3003bd8 	movw	r3, #3032	; 0xbd8
20001404:	e3423000 	movt	r3, #8192	; 0x2000
20001408:	e12fff33 	blx	r3
2000140c:	eaffffe5 	b	200013a8 <nic_receive+0x8c>

20001410 <nic_init>:
void nic_send(struct netbuf* buf) {

}

// Configures the NIC hardware and enables the NIC interface
void nic_init() {
20001410:	e92d4070 	push	{r4, r5, r6, lr}
20001414:	e24dd008 	sub	sp, sp, #8
    // Enable clock and pins
    sama5d2_per_clk_en(5);
20001418:	e3a00005 	mov	r0, #5
2000141c:	e3003dd8 	movw	r3, #3544	; 0xdd8
20001420:	e3423000 	movt	r3, #8192	; 0x2000
20001424:	e12fff33 	blx	r3
    nic_pin_init();
20001428:	e3013264 	movw	r3, #4708	; 0x1264
2000142c:	e3423000 	movt	r3, #8192	; 0x2000
20001430:	e12fff33 	blx	r3

    //Setup the DMA queues
    nic_setup_dma_queues();
20001434:	e3003e44 	movw	r3, #3652	; 0xe44
20001438:	e3423000 	movt	r3, #8192	; 0x2000
2000143c:	e12fff33 	blx	r3

    struct nic_reg* const nic_reg = NIC_REG;
    
    // Enable the PHY management interface and set the bus speed
    nic_reg->ncr |= (1 << 4);
20001440:	e3a04902 	mov	r4, #32768	; 0x8000
20001444:	e34f4800 	movt	r4, #63488	; 0xf800
20001448:	e5943000 	ldr	r3, [r4]
2000144c:	e3833010 	orr	r3, r3, #16
20001450:	e5843000 	str	r3, [r4]
    nic_reg->ncfgr = (nic_reg->ncfgr & ~(0x7 << 18)) | (5 << 18);
20001454:	e5943004 	ldr	r3, [r4, #4]
20001458:	e3c33707 	bic	r3, r3, #1835008	; 0x1c0000
2000145c:	e3833705 	orr	r3, r3, #1310720	; 0x140000
20001460:	e5843004 	str	r3, [r4, #4]
    
    phy_addr = ethernet_phy_scan();
20001464:	e301310c 	movw	r3, #4364	; 0x110c
20001468:	e3423000 	movt	r3, #8192	; 0x2000
2000146c:	e12fff33 	blx	r3
20001470:	e30463c8 	movw	r6, #17352	; 0x43c8
20001474:	e3426006 	movt	r6, #8198	; 0x2006
20001478:	e5c60000 	strb	r0, [r6]
    phy_establish_link(phy_addr);
2000147c:	e3013168 	movw	r3, #4456	; 0x1168
20001480:	e3423000 	movt	r3, #8192	; 0x2000
20001484:	e12fff33 	blx	r3
    kprint("Link is up\n");
20001488:	e30106b8 	movw	r0, #5816	; 0x16b8
2000148c:	e3420000 	movt	r0, #8192	; 0x2000
20001490:	e3005b08 	movw	r5, #2824	; 0xb08
20001494:	e3425000 	movt	r5, #8192	; 0x2000
20001498:	e12fff35 	blx	r5

    struct nic_link_setting link_setting;

    get_phy_settings(phy_addr, &link_setting);
2000149c:	e28d1004 	add	r1, sp, #4
200014a0:	e5d60000 	ldrb	r0, [r6]
200014a4:	e3013220 	movw	r3, #4640	; 0x1220
200014a8:	e3423000 	movt	r3, #8192	; 0x2000
200014ac:	e12fff33 	blx	r3

    kprint("Print speed setting => {d}\n", link_setting.speed);
200014b0:	e5dd1004 	ldrb	r1, [sp, #4]
200014b4:	e30106c4 	movw	r0, #5828	; 0x16c4
200014b8:	e3420000 	movt	r0, #8192	; 0x2000
200014bc:	e12fff35 	blx	r5
    kprint("Print duplex setting => {d}\n", link_setting.duplex);
200014c0:	e5dd1005 	ldrb	r1, [sp, #5]
200014c4:	e30106e0 	movw	r0, #5856	; 0x16e0
200014c8:	e3420000 	movt	r0, #8192	; 0x2000
200014cc:	e12fff35 	blx	r5

    // Copy all frames, 100Mbps and full-duplex configuration
    nic_reg->ncfgr = (1 << 0) | (1 << 1) | (1 << 4);
200014d0:	e3a03013 	mov	r3, #19
200014d4:	e5843004 	str	r3, [r4, #4]

    // Configure for RMII mode
    nic_reg->ur = (1 << 0);
200014d8:	e3a03001 	mov	r3, #1
200014dc:	e584300c 	str	r3, [r4, #12]

    // DMA configuration
    nic_reg->dcfgr = (4 << 0) | (3 << 8) | (1 << 10) | (0x18 << 16);
200014e0:	e3003704 	movw	r3, #1796	; 0x704
200014e4:	e3403018 	movt	r3, #24
200014e8:	e5843010 	str	r3, [r4, #16]

    // Ignore interrupts
    nic_reg->idr = 0xFFFFFFFF;
200014ec:	e3e03000 	mvn	r3, #0
200014f0:	e584302c 	str	r3, [r4, #44]	; 0x2c

    // Enable receiver and transmitter
    nic_reg->ncr |= (1 << 2) | (1 << 3);
200014f4:	e5943000 	ldr	r3, [r4]
200014f8:	e383300c 	orr	r3, r3, #12
200014fc:	e5843000 	str	r3, [r4]

    boot_message("Started kernel NIC driver for SAMA5D2\n");
20001500:	e3010700 	movw	r0, #5888	; 0x1700
20001504:	e3420000 	movt	r0, #8192	; 0x2000
20001508:	e3003b60 	movw	r3, #2912	; 0xb60
2000150c:	e3423000 	movt	r3, #8192	; 0x2000
20001510:	e12fff33 	blx	r3
}
20001514:	e28dd008 	add	sp, sp, #8
20001518:	e8bd8070 	pop	{r4, r5, r6, pc}

Disassembly of section .init:

2000151c <_init>:
2000151c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000151e:	bf00      	nop

Disassembly of section .fini:

20001520 <_fini>:
20001520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20001522:	bf00      	nop
