
/home/strawberry/chaos/build/sama5/sama5d27_som_ek.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .kernel_entry 00000108  20000000  20000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0000142c  20000108  20000108  00010108  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  20001534  20001534  00011534  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  20001538  20001538  00011538  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000234  2000153c  2000153c  0001153c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000438  20001770  20001770  00011770  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00062a7c  20001bc0  20001bc0  00011ba8  2**5
                  ALLOC
  7 .stack        00000c04  2006463c  2006463c  00011ba8  2**0
                  ALLOC
  8 .ARM.attributes 0000002d  00000000  00000000  00011ba8  2**0
                  CONTENTS, READONLY
  9 .comment      000000a7  00000000  00000000  00011bd5  2**0
                  CONTENTS, READONLY
 10 .debug_line   00002f67  00000000  00000000  00011c7c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_info   00007c4a  00000000  00000000  00014be3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 000021db  00000000  00000000  0001c82d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 000003d8  00000000  00000000  0001ea08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00005d0e  00000000  00000000  0001ede0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    000020e2  00000000  00000000  00024aee  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000390  00000000  00000000  00026bd0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00001651  00000000  00000000  00026f60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  000005ec  00000000  00000000  000285b4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .kernel_entry:

20000000 <_kernel_s>:
// This is where u-boot (or any bootloader) will hand off execution
.section .kernel_entry, "ax", %progbits
kernel_entry:

    // Get the program load address
    sub r0, pc, #8
20000000:	e24f0008 	sub	r0, pc, #8
    ldr r1, =ddr_start
20000004:	e59f10ec 	ldr	r1, [pc, #236]	; 200000f8 <skip_kernel_relocation+0x10>

    // Turn off all interrupts
    cpsid afi
20000008:	f10c01c0 	cpsid	aif

    // Check if a relocation is needed
    cmp r0, r1
2000000c:	e1500001 	cmp	r0, r1
    beq skip_kernel_relocation
20000010:	0a000034 	beq	200000e8 <skip_kernel_relocation>

20000014 <relocate_kernel>:

relocate_kernel:
    // Check if the relocation will overwrite executing code
    ldr r2, =_kernel_size
20000014:	e59f20e0 	ldr	r2, [pc, #224]	; 200000fc <skip_kernel_relocation+0x14>
    add r3, r2, #4
20000018:	e2823004 	add	r3, r2, #4
    add r4, r1, r2                     // r4 hold the upper address affected by the relocation
2000001c:	e0814002 	add	r4, r1, r2
    cmp r4, r0
20000020:	e1540000 	cmp	r4, r0
    bls .
20000024:	9afffffe 	bls	20000024 <relocate_kernel+0x10>

    lsr r2, r2, #2
20000028:	e1a02122 	lsr	r2, r2, #2
    add r2, r2, #1                     // Kernel size in words
2000002c:	e2822001 	add	r2, r2, #1

    // Relocate the kernel to the start of DDR memory
1:  ldr r3, [r0], #4
20000030:	e4903004 	ldr	r3, [r0], #4
    str r3, [r1], #4
20000034:	e4813004 	str	r3, [r1], #4
    subs r2, r2, #1
20000038:	e2522001 	subs	r2, r2, #1
    bne 1b
2000003c:	1afffffb 	bne	20000030 <relocate_kernel+0x1c>

    // Check if the dcache is enabled
    mrc p15, 0, r0, c1, c0, 0
20000040:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst r0, #(1 << 2)
20000044:	e3100004 	tst	r0, #4
    beq skip_disable_dcache
20000048:	0a00001b 	beq	200000bc <skip_disable_dcache>

    // Get the cache size
    mrc p15, 1, r5, c0, c0, 0
2000004c:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
    lsr r3, r5, #3
20000050:	e1a031a5 	lsr	r3, r5, #3
    mov r6, #0x3FF
20000054:	e30063ff 	movw	r6, #1023	; 0x3ff
    and r3, r3, r6
20000058:	e0033006 	and	r3, r3, r6
    add r3, r3, #1                     // Number of ways
2000005c:	e2833001 	add	r3, r3, #1

    mov r6, #0x7FFF
20000060:	e3076fff 	movw	r6, #32767	; 0x7fff
    lsr r4, r5, #13
20000064:	e1a046a5 	lsr	r4, r5, #13
    and r4, r4, r6
20000068:	e0044006 	and	r4, r4, r6
    add r4, r4, #1                     // Number of sets
2000006c:	e2844001 	add	r4, r4, #1

    // Disable and clean the dcache
    mov r0, #0                         // Way index
20000070:	e3a00000 	mov	r0, #0
1:  mov r1, #0                         // Set index
20000074:	e3a01000 	mov	r1, #0
2:  mov r2, #0
20000078:	e3a02000 	mov	r2, #0
    orr r2, r2, r1, LSL #5
2000007c:	e1822281 	orr	r2, r2, r1, lsl #5
    orr r2, r2, r0, LSL #30
20000080:	e1822f00 	orr	r2, r2, r0, lsl #30
    mcr p15, 0, r2, c7, c10, 2
20000084:	ee072f5a 	mcr	15, 0, r2, cr7, cr10, {2}
    add r1, r1, #1
20000088:	e2811001 	add	r1, r1, #1
    cmp r1, r4
2000008c:	e1510004 	cmp	r1, r4
    bne 2b
20000090:	1afffff8 	bne	20000078 <relocate_kernel+0x64>
    add r0, r0, #1
20000094:	e2800001 	add	r0, r0, #1
    cmp r0, r3
20000098:	e1500003 	cmp	r0, r3
    bne 1b
2000009c:	1afffff4 	bne	20000074 <relocate_kernel+0x60>
    dsb
200000a0:	f57ff04f 	dsb	sy
    isb
200000a4:	f57ff06f 	isb	sy

    // Disable the D-cache
    mrc p15, 0, r0, c1, c0, 0
200000a8:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic r0, #(1 << 2)
200000ac:	e3c00004 	bic	r0, r0, #4
    mcr p15, 0, r0, c1, c0, 0
200000b0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dmb
200000b4:	f57ff05f 	dmb	sy
    isb
200000b8:	f57ff06f 	isb	sy

200000bc <skip_disable_dcache>:
    
skip_disable_dcache:
    // Check if the icache is enabled
    mrc p15, 0, r0, c1, c0, 0
200000bc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst r0, #(1 << 12)
200000c0:	e3100a01 	tst	r0, #4096	; 0x1000
    beq skip_invalidate_icache
200000c4:	0a000003 	beq	200000d8 <skip_invalidate_icache>

    // Invalidate the icache
    mov r0, #0
200000c8:	e3a00000 	mov	r0, #0
    mcr p15, 0, r0, c7, c5, 0
200000cc:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
    dsb
200000d0:	f57ff04f 	dsb	sy
    isb
200000d4:	f57ff06f 	isb	sy

200000d8 <skip_invalidate_icache>:

skip_invalidate_icache:

    // Relocation is complete so we can jump to the beginning of DDR
    ldr r1, =ddr_start
200000d8:	e59f1018 	ldr	r1, [pc, #24]	; 200000f8 <skip_kernel_relocation+0x10>
    dsb
200000dc:	f57ff04f 	dsb	sy
    isb
200000e0:	f57ff06f 	isb	sy
    bx r1
200000e4:	e12fff11 	bx	r1

200000e8 <skip_kernel_relocation>:
skip_kernel_relocation:
    // We are done relocating the kernel. We require that MMU, interrupt and D-cache is
    // disabled at this point. This will be the main entry point for the kernel

    // Setup the stack for the SVC mode
    ldr sp, =_svc_stack_e
200000e8:	e59fd010 	ldr	sp, [pc, #16]	; 20000100 <skip_kernel_relocation+0x18>
    isb
200000ec:	f57ff06f 	isb	sy

    // Setup early kernel pagetables for upper 2 GB

    // Might have to do a physical to virtual address switch before the branch

    ldr r0, =main
200000f0:	e59f000c 	ldr	r0, [pc, #12]	; 20000104 <skip_kernel_relocation+0x1c>
    bx r0
200000f4:	e12fff10 	bx	r0
    ldr r1, =ddr_start
200000f8:	20000000 	.word	0x20000000
    ldr r2, =_kernel_size
200000fc:	00001ba8 	.word	0x00001ba8
    ldr sp, =_svc_stack_e
20000100:	20065040 	.word	0x20065040
    ldr r0, =main
20000104:	20000a48 	.word	0x20000a48

Disassembly of section .text:

20000108 <__udivsi3>:
20000108:	1e4a      	subs	r2, r1, #1
2000010a:	bf08      	it	eq
2000010c:	4770      	bxeq	lr
2000010e:	f0c0 8124 	bcc.w	2000035a <__udivsi3+0x252>
20000112:	4288      	cmp	r0, r1
20000114:	f240 8116 	bls.w	20000344 <__udivsi3+0x23c>
20000118:	4211      	tst	r1, r2
2000011a:	f000 8117 	beq.w	2000034c <__udivsi3+0x244>
2000011e:	fab0 f380 	clz	r3, r0
20000122:	fab1 f281 	clz	r2, r1
20000126:	eba2 0303 	sub.w	r3, r2, r3
2000012a:	f1c3 031f 	rsb	r3, r3, #31
2000012e:	a204      	add	r2, pc, #16	; (adr r2, 20000140 <__udivsi3+0x38>)
20000130:	eb02 1303 	add.w	r3, r2, r3, lsl #4
20000134:	f04f 0200 	mov.w	r2, #0
20000138:	469f      	mov	pc, r3
2000013a:	bf00      	nop
2000013c:	f3af 8000 	nop.w
20000140:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
20000144:	bf00      	nop
20000146:	eb42 0202 	adc.w	r2, r2, r2
2000014a:	bf28      	it	cs
2000014c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
20000150:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
20000154:	bf00      	nop
20000156:	eb42 0202 	adc.w	r2, r2, r2
2000015a:	bf28      	it	cs
2000015c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
20000160:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
20000164:	bf00      	nop
20000166:	eb42 0202 	adc.w	r2, r2, r2
2000016a:	bf28      	it	cs
2000016c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
20000170:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
20000174:	bf00      	nop
20000176:	eb42 0202 	adc.w	r2, r2, r2
2000017a:	bf28      	it	cs
2000017c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
20000180:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
20000184:	bf00      	nop
20000186:	eb42 0202 	adc.w	r2, r2, r2
2000018a:	bf28      	it	cs
2000018c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
20000190:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
20000194:	bf00      	nop
20000196:	eb42 0202 	adc.w	r2, r2, r2
2000019a:	bf28      	it	cs
2000019c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
200001a0:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
200001a4:	bf00      	nop
200001a6:	eb42 0202 	adc.w	r2, r2, r2
200001aa:	bf28      	it	cs
200001ac:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
200001b0:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
200001b4:	bf00      	nop
200001b6:	eb42 0202 	adc.w	r2, r2, r2
200001ba:	bf28      	it	cs
200001bc:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
200001c0:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
200001c4:	bf00      	nop
200001c6:	eb42 0202 	adc.w	r2, r2, r2
200001ca:	bf28      	it	cs
200001cc:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
200001d0:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
200001d4:	bf00      	nop
200001d6:	eb42 0202 	adc.w	r2, r2, r2
200001da:	bf28      	it	cs
200001dc:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
200001e0:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
200001e4:	bf00      	nop
200001e6:	eb42 0202 	adc.w	r2, r2, r2
200001ea:	bf28      	it	cs
200001ec:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
200001f0:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
200001f4:	bf00      	nop
200001f6:	eb42 0202 	adc.w	r2, r2, r2
200001fa:	bf28      	it	cs
200001fc:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
20000200:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
20000204:	bf00      	nop
20000206:	eb42 0202 	adc.w	r2, r2, r2
2000020a:	bf28      	it	cs
2000020c:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
20000210:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
20000214:	bf00      	nop
20000216:	eb42 0202 	adc.w	r2, r2, r2
2000021a:	bf28      	it	cs
2000021c:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
20000220:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
20000224:	bf00      	nop
20000226:	eb42 0202 	adc.w	r2, r2, r2
2000022a:	bf28      	it	cs
2000022c:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
20000230:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
20000234:	bf00      	nop
20000236:	eb42 0202 	adc.w	r2, r2, r2
2000023a:	bf28      	it	cs
2000023c:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
20000240:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
20000244:	bf00      	nop
20000246:	eb42 0202 	adc.w	r2, r2, r2
2000024a:	bf28      	it	cs
2000024c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
20000250:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
20000254:	bf00      	nop
20000256:	eb42 0202 	adc.w	r2, r2, r2
2000025a:	bf28      	it	cs
2000025c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
20000260:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
20000264:	bf00      	nop
20000266:	eb42 0202 	adc.w	r2, r2, r2
2000026a:	bf28      	it	cs
2000026c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
20000270:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
20000274:	bf00      	nop
20000276:	eb42 0202 	adc.w	r2, r2, r2
2000027a:	bf28      	it	cs
2000027c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
20000280:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
20000284:	bf00      	nop
20000286:	eb42 0202 	adc.w	r2, r2, r2
2000028a:	bf28      	it	cs
2000028c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
20000290:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
20000294:	bf00      	nop
20000296:	eb42 0202 	adc.w	r2, r2, r2
2000029a:	bf28      	it	cs
2000029c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
200002a0:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
200002a4:	bf00      	nop
200002a6:	eb42 0202 	adc.w	r2, r2, r2
200002aa:	bf28      	it	cs
200002ac:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
200002b0:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
200002b4:	bf00      	nop
200002b6:	eb42 0202 	adc.w	r2, r2, r2
200002ba:	bf28      	it	cs
200002bc:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
200002c0:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
200002c4:	bf00      	nop
200002c6:	eb42 0202 	adc.w	r2, r2, r2
200002ca:	bf28      	it	cs
200002cc:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
200002d0:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
200002d4:	bf00      	nop
200002d6:	eb42 0202 	adc.w	r2, r2, r2
200002da:	bf28      	it	cs
200002dc:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
200002e0:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
200002e4:	bf00      	nop
200002e6:	eb42 0202 	adc.w	r2, r2, r2
200002ea:	bf28      	it	cs
200002ec:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
200002f0:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
200002f4:	bf00      	nop
200002f6:	eb42 0202 	adc.w	r2, r2, r2
200002fa:	bf28      	it	cs
200002fc:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
20000300:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
20000304:	bf00      	nop
20000306:	eb42 0202 	adc.w	r2, r2, r2
2000030a:	bf28      	it	cs
2000030c:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
20000310:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
20000314:	bf00      	nop
20000316:	eb42 0202 	adc.w	r2, r2, r2
2000031a:	bf28      	it	cs
2000031c:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
20000320:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
20000324:	bf00      	nop
20000326:	eb42 0202 	adc.w	r2, r2, r2
2000032a:	bf28      	it	cs
2000032c:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
20000330:	ebb0 0f01 	cmp.w	r0, r1
20000334:	bf00      	nop
20000336:	eb42 0202 	adc.w	r2, r2, r2
2000033a:	bf28      	it	cs
2000033c:	eba0 0001 	subcs.w	r0, r0, r1
20000340:	4610      	mov	r0, r2
20000342:	4770      	bx	lr
20000344:	bf0c      	ite	eq
20000346:	2001      	moveq	r0, #1
20000348:	2000      	movne	r0, #0
2000034a:	4770      	bx	lr
2000034c:	fab1 f281 	clz	r2, r1
20000350:	f1c2 021f 	rsb	r2, r2, #31
20000354:	fa20 f002 	lsr.w	r0, r0, r2
20000358:	4770      	bx	lr
2000035a:	b108      	cbz	r0, 20000360 <__udivsi3+0x258>
2000035c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
20000360:	f000 b80e 	b.w	20000380 <__aeabi_idiv0>

20000364 <__aeabi_uidivmod>:
20000364:	2900      	cmp	r1, #0
20000366:	d0f8      	beq.n	2000035a <__udivsi3+0x252>
20000368:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
2000036c:	f7ff fecc 	bl	20000108 <__udivsi3>
20000370:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
20000374:	fb02 f300 	mul.w	r3, r2, r0
20000378:	eba1 0103 	sub.w	r1, r1, r3
2000037c:	4770      	bx	lr
2000037e:	bf00      	nop

20000380 <__aeabi_idiv0>:
20000380:	4770      	bx	lr
20000382:	bf00      	nop

20000384 <print_format_to_buf_arg>:
    if (*buf < end) {
        *(*buf)++ = c;
    }
}

u32 print_format_to_buf_arg(char* buf, u32 len, const char* str, va_list arg) {
20000384:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
20000388:	e24dd05c 	sub	sp, sp, #92	; 0x5c
2000038c:	e1a0a000 	mov	sl, r0
20000390:	e58d1004 	str	r1, [sp, #4]
20000394:	e1a0c002 	mov	ip, r2
    // Save the end of the buffer so that we can detect overflow
    char* const end = buf + len;
20000398:	e080b001 	add	fp, r0, r1

    for (; *str; str++) {
2000039c:	e5d21000 	ldrb	r1, [r2]
200003a0:	e3510000 	cmp	r1, #0
200003a4:	0a000166 	beq	20000944 <print_format_to_buf_arg+0x5c0>
200003a8:	e1a02003 	mov	r2, r3
            }

            // Convert the number to string representation
            u32 num_pos = (u32)num;
            do {
                num_buf[index++] = number_lookup[num_pos % base] | lowercase;
200003ac:	e3013540 	movw	r3, #5440	; 0x1540
200003b0:	e3423000 	movt	r3, #8192	; 0x2000
200003b4:	e58d3000 	str	r3, [sp]
200003b8:	e3003365 	movw	r3, #869	; 0x365
200003bc:	e3423000 	movt	r3, #8192	; 0x2000
200003c0:	e58d300c 	str	r3, [sp, #12]
                num_pos /= base;
200003c4:	e3003109 	movw	r3, #265	; 0x109
200003c8:	e3423000 	movt	r3, #8192	; 0x2000
200003cc:	e58d3010 	str	r3, [sp, #16]
        *(*buf)++ = c;
200003d0:	e1a0900b 	mov	r9, fp
200003d4:	ea000084 	b	200005ec <print_format_to_buf_arg+0x268>
        while (*++str) {
200003d8:	e28c4001 	add	r4, ip, #1
200003dc:	e5dc3001 	ldrb	r3, [ip, #1]
200003e0:	e3530000 	cmp	r3, #0
        u16 flags = 0;
200003e4:	03a05000 	moveq	r5, #0
        while (*++str) {
200003e8:	0a000016 	beq	20000448 <print_format_to_buf_arg+0xc4>
        u16 flags = 0;
200003ec:	e3a05000 	mov	r5, #0
200003f0:	ea000003 	b	20000404 <print_format_to_buf_arg+0x80>
            else if (*str == ' ') flags |= FLAG_SIGN_IGNORE;
200003f4:	e3855008 	orr	r5, r5, #8
        while (*++str) {
200003f8:	e5f43001 	ldrb	r3, [r4, #1]!
200003fc:	e3530000 	cmp	r3, #0
20000400:	0a000010 	beq	20000448 <print_format_to_buf_arg+0xc4>
20000404:	e2441001 	sub	r1, r4, #1
            if      (*str == '!') flags |= FLAG_PREFIX;
20000408:	e3530021 	cmp	r3, #33	; 0x21
2000040c:	03855001 	orreq	r5, r5, #1
20000410:	0afffff8 	beq	200003f8 <print_format_to_buf_arg+0x74>
            else if (*str == '<') flags |= FLAG_LEFT;
20000414:	e353003c 	cmp	r3, #60	; 0x3c
20000418:	03855002 	orreq	r5, r5, #2
2000041c:	0afffff5 	beq	200003f8 <print_format_to_buf_arg+0x74>
            else if (*str == '0') flags |= FLAG_ZERO;
20000420:	e3530030 	cmp	r3, #48	; 0x30
20000424:	03855004 	orreq	r5, r5, #4
20000428:	0afffff2 	beq	200003f8 <print_format_to_buf_arg+0x74>
            else if (*str == '+') flags |= FLAG_SIGN_FORCE;
2000042c:	e353002b 	cmp	r3, #43	; 0x2b
20000430:	03855010 	orreq	r5, r5, #16
20000434:	0affffef 	beq	200003f8 <print_format_to_buf_arg+0x74>
            else if (*str == ' ') flags |= FLAG_SIGN_IGNORE;
20000438:	e3530020 	cmp	r3, #32
2000043c:	0affffec 	beq	200003f4 <print_format_to_buf_arg+0x70>
        if (*str == ':') {
20000440:	e353003a 	cmp	r3, #58	; 0x3a
            str++;
20000444:	02814002 	addeq	r4, r1, #2
        if (*str == '_') {
20000448:	e5d43000 	ldrb	r3, [r4]
2000044c:	e353005f 	cmp	r3, #95	; 0x5f
            width = (i32)va_arg(arg, int);
20000450:	04927004 	ldreq	r7, [r2], #4
            str++;
20000454:	02844001 	addeq	r4, r4, #1
        if (*str == '_') {
20000458:	0a000004 	beq	20000470 <print_format_to_buf_arg+0xec>
        } else if (*str >= '0' && *str <= '9') {
2000045c:	e2431030 	sub	r1, r3, #48	; 0x30
20000460:	e6ef1071 	uxtb	r1, r1
20000464:	e3510009 	cmp	r1, #9
        i32 width = -1;
20000468:	83e07000 	mvnhi	r7, #0
        } else if (*str >= '0' && *str <= '9') {
2000046c:	9a000041 	bls	20000578 <print_format_to_buf_arg+0x1f4>
        if (*str == ':') {
20000470:	e5d43000 	ldrb	r3, [r4]
20000474:	e353003a 	cmp	r3, #58	; 0x3a
            str++;
20000478:	02844001 	addeq	r4, r4, #1
        switch (*str++) {
2000047c:	e5d43000 	ldrb	r3, [r4]
20000480:	e2433042 	sub	r3, r3, #66	; 0x42
20000484:	e3530039 	cmp	r3, #57	; 0x39
20000488:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
2000048c:	ea000052 	b	200005dc <print_format_to_buf_arg+0x258>
20000490:	2000062c 	.word	0x2000062c
20000494:	20000608 	.word	0x20000608
20000498:	200005dc 	.word	0x200005dc
2000049c:	200005dc 	.word	0x200005dc
200004a0:	200005dc 	.word	0x200005dc
200004a4:	200005dc 	.word	0x200005dc
200004a8:	200005dc 	.word	0x200005dc
200004ac:	200005dc 	.word	0x200005dc
200004b0:	200005dc 	.word	0x200005dc
200004b4:	200005dc 	.word	0x200005dc
200004b8:	200005dc 	.word	0x200005dc
200004bc:	200005dc 	.word	0x200005dc
200004c0:	200005dc 	.word	0x200005dc
200004c4:	200005dc 	.word	0x200005dc
200004c8:	20000634 	.word	0x20000634
200004cc:	200005dc 	.word	0x200005dc
200004d0:	20000644 	.word	0x20000644
200004d4:	200005a8 	.word	0x200005a8
200004d8:	200005dc 	.word	0x200005dc
200004dc:	200005dc 	.word	0x200005dc
200004e0:	200005dc 	.word	0x200005dc
200004e4:	200005dc 	.word	0x200005dc
200004e8:	200005a0 	.word	0x200005a0
200004ec:	200005dc 	.word	0x200005dc
200004f0:	200005dc 	.word	0x200005dc
200004f4:	200005dc 	.word	0x200005dc
200004f8:	200005dc 	.word	0x200005dc
200004fc:	200005dc 	.word	0x200005dc
20000500:	200005dc 	.word	0x200005dc
20000504:	200005dc 	.word	0x200005dc
20000508:	200005dc 	.word	0x200005dc
2000050c:	200005dc 	.word	0x200005dc
20000510:	2000062c 	.word	0x2000062c
20000514:	20000608 	.word	0x20000608
20000518:	20000660 	.word	0x20000660
2000051c:	200005dc 	.word	0x200005dc
20000520:	200005dc 	.word	0x200005dc
20000524:	200005dc 	.word	0x200005dc
20000528:	200005dc 	.word	0x200005dc
2000052c:	20000614 	.word	0x20000614
20000530:	200005dc 	.word	0x200005dc
20000534:	200005dc 	.word	0x200005dc
20000538:	200005dc 	.word	0x200005dc
2000053c:	200005dc 	.word	0x200005dc
20000540:	200005dc 	.word	0x200005dc
20000544:	200005dc 	.word	0x200005dc
20000548:	20000634 	.word	0x20000634
2000054c:	200005dc 	.word	0x200005dc
20000550:	20000644 	.word	0x20000644
20000554:	200005a8 	.word	0x200005a8
20000558:	200005dc 	.word	0x200005dc
2000055c:	20000660 	.word	0x20000660
20000560:	200005dc 	.word	0x200005dc
20000564:	200005dc 	.word	0x200005dc
20000568:	20000620 	.word	0x20000620
2000056c:	200005dc 	.word	0x200005dc
20000570:	200005dc 	.word	0x200005dc
20000574:	20000654 	.word	0x20000654
            width = 0;
20000578:	e3a07000 	mov	r7, #0
                width = width * 10 + (*str++ - '0');
2000057c:	e3a0000a 	mov	r0, #10
20000580:	e2433030 	sub	r3, r3, #48	; 0x30
20000584:	e0273790 	mla	r7, r0, r7, r3
            while (*str >= '0' && *str <= '9') {
20000588:	e5f43001 	ldrb	r3, [r4, #1]!
2000058c:	e2431030 	sub	r1, r3, #48	; 0x30
20000590:	e6ef1071 	uxtb	r1, r1
20000594:	e3510009 	cmp	r1, #9
20000598:	9afffff8 	bls	20000580 <print_format_to_buf_arg+0x1fc>
2000059c:	eaffffb3 	b	20000470 <print_format_to_buf_arg+0xec>
        switch (*str++) {
200005a0:	e3a0b010 	mov	fp, #16
200005a4:	ea000001 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_STRING;
200005a8:	e3855080 	orr	r5, r5, #128	; 0x80
        u8 base = 10;
200005ac:	e3a0b00a 	mov	fp, #10
        if (flags & FLAG_CHAR) {
200005b0:	e3150c01 	tst	r5, #256	; 0x100
200005b4:	0a00002b 	beq	20000668 <print_format_to_buf_arg+0x2e4>
            put_char((char)va_arg(arg, int), &buf, end);
200005b8:	e2823004 	add	r3, r2, #4
    if (*buf < end) {
200005bc:	e159000a 	cmp	r9, sl
            put_char((char)va_arg(arg, int), &buf, end);
200005c0:	91a02003 	movls	r2, r3
200005c4:	85922000 	ldrhi	r2, [r2]
200005c8:	84ca2001 	strbhi	r2, [sl], #1
200005cc:	81a02003 	movhi	r2, r3
                }
            }
        }

        // If the user don't write ending bracket we don't skrip the next character
        if (*str != '}') {
200005d0:	e5d43001 	ldrb	r3, [r4, #1]
200005d4:	e353007d 	cmp	r3, #125	; 0x7d
        switch (*str++) {
200005d8:	02844001 	addeq	r4, r4, #1
    for (; *str; str++) {
200005dc:	e284c001 	add	ip, r4, #1
200005e0:	e5d41001 	ldrb	r1, [r4, #1]
200005e4:	e3510000 	cmp	r1, #0
200005e8:	0a0000d4 	beq	20000940 <print_format_to_buf_arg+0x5bc>
        if (*str != '{') {
200005ec:	e351007b 	cmp	r1, #123	; 0x7b
200005f0:	0affff78 	beq	200003d8 <print_format_to_buf_arg+0x54>
    if (*buf < end) {
200005f4:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200005f8:	84ca1001 	strbhi	r1, [sl], #1
200005fc:	81a0400c 	movhi	r4, ip
    if (*buf < end) {
20000600:	91a0400c 	movls	r4, ip
20000604:	eafffff4 	b	200005dc <print_format_to_buf_arg+0x258>
                flags |= FLAG_CHAR;
20000608:	e3855c01 	orr	r5, r5, #256	; 0x100
        u8 base = 10;
2000060c:	e3a0b00a 	mov	fp, #10
                break;
20000610:	eaffffe6 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_SIGN;
20000614:	e3855040 	orr	r5, r5, #64	; 0x40
        u8 base = 10;
20000618:	e3a0b00a 	mov	fp, #10
2000061c:	eaffffe3 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_LOWERCASE;
20000620:	e3855020 	orr	r5, r5, #32
                base = 16;
20000624:	e3a0b010 	mov	fp, #16
20000628:	eaffffe0 	b	200005b0 <print_format_to_buf_arg+0x22c>
                base = 2;
2000062c:	e3a0b002 	mov	fp, #2
                break;
20000630:	eaffffde 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_PREFIX;
20000634:	e3855001 	orr	r5, r5, #1
                base = 16;
20000638:	e3a0b010 	mov	fp, #16
                width = 8;
2000063c:	e3a07008 	mov	r7, #8
                break;
20000640:	eaffffda 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_PREFIX | FLAG_ZERO;
20000644:	e3855005 	orr	r5, r5, #5
                base = 2;
20000648:	e3a0b002 	mov	fp, #2
                width = 34;
2000064c:	e3a07022 	mov	r7, #34	; 0x22
                break;
20000650:	eaffffd6 	b	200005b0 <print_format_to_buf_arg+0x22c>
                flags |= FLAG_BRACKET;
20000654:	e3855c02 	orr	r5, r5, #512	; 0x200
        u8 base = 10;
20000658:	e3a0b00a 	mov	fp, #10
                break;
2000065c:	eaffffd3 	b	200005b0 <print_format_to_buf_arg+0x22c>
        u8 base = 10;
20000660:	e3a0b00a 	mov	fp, #10
20000664:	eaffffd1 	b	200005b0 <print_format_to_buf_arg+0x22c>
        } else if (flags & FLAG_STRING) {
20000668:	e3150080 	tst	r5, #128	; 0x80
2000066c:	0a000035 	beq	20000748 <print_format_to_buf_arg+0x3c4>
            const char* ptr = (const char *)va_arg(arg, char *);
20000670:	e4920004 	ldr	r0, [r2], #4
            if (width < 0) {
20000674:	e3570000 	cmp	r7, #0
20000678:	ba000023 	blt	2000070c <print_format_to_buf_arg+0x388>
                for (i = 0; (i < width) && ptr[i]; i++);
2000067c:	e1a0e007 	mov	lr, r7
20000680:	0a0000df 	beq	20000a04 <print_format_to_buf_arg+0x680>
20000684:	e2403001 	sub	r3, r0, #1
20000688:	e3a0c000 	mov	ip, #0
2000068c:	e5f31001 	ldrb	r1, [r3, #1]!
20000690:	e3510000 	cmp	r1, #0
20000694:	0a000025 	beq	20000730 <print_format_to_buf_arg+0x3ac>
20000698:	e28cc001 	add	ip, ip, #1
2000069c:	e15c000e 	cmp	ip, lr
200006a0:	1afffff9 	bne	2000068c <print_format_to_buf_arg+0x308>
                if ((flags & FLAG_LEFT) == 0) {
200006a4:	e2155002 	ands	r5, r5, #2
200006a8:	0a0000aa 	beq	20000958 <print_format_to_buf_arg+0x5d4>
                u32 padding = width - i;
200006ac:	e3a01000 	mov	r1, #0
                while (i--) {
200006b0:	e24e3001 	sub	r3, lr, #1
200006b4:	e35e0000 	cmp	lr, #0
200006b8:	0a000009 	beq	200006e4 <print_format_to_buf_arg+0x360>
200006bc:	e2833001 	add	r3, r3, #1
200006c0:	e0803003 	add	r3, r0, r3
                    put_char(*ptr++, &buf, end);
200006c4:	e2800001 	add	r0, r0, #1
    if (*buf < end) {
200006c8:	e159000a 	cmp	r9, sl
                    put_char(*ptr++, &buf, end);
200006cc:	8550c001 	ldrbhi	ip, [r0, #-1]
        *(*buf)++ = c;
200006d0:	84cac001 	strbhi	ip, [sl], #1
                while (i--) {
200006d4:	e1500003 	cmp	r0, r3
200006d8:	1afffff9 	bne	200006c4 <print_format_to_buf_arg+0x340>
                if (flags & FLAG_LEFT) {
200006dc:	e3550000 	cmp	r5, #0
200006e0:	0affffba 	beq	200005d0 <print_format_to_buf_arg+0x24c>
                    while (padding--) {
200006e4:	e2413001 	sub	r3, r1, #1
200006e8:	e3510000 	cmp	r1, #0
200006ec:	0affffb7 	beq	200005d0 <print_format_to_buf_arg+0x24c>
    if (*buf < end) {
200006f0:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200006f4:	83a01020 	movhi	r1, #32
200006f8:	84ca1001 	strbhi	r1, [sl], #1
                    while (padding--) {
200006fc:	e2433001 	sub	r3, r3, #1
20000700:	e3730001 	cmn	r3, #1
20000704:	1afffff9 	bne	200006f0 <print_format_to_buf_arg+0x36c>
20000708:	eaffffb0 	b	200005d0 <print_format_to_buf_arg+0x24c>
                while (*ptr) {
2000070c:	e5d03000 	ldrb	r3, [r0]
20000710:	e3530000 	cmp	r3, #0
20000714:	0affffad 	beq	200005d0 <print_format_to_buf_arg+0x24c>
    if (*buf < end) {
20000718:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
2000071c:	84ca3001 	strbhi	r3, [sl], #1
                while (*ptr) {
20000720:	e5f03001 	ldrb	r3, [r0, #1]!
20000724:	e3530000 	cmp	r3, #0
20000728:	1afffffa 	bne	20000718 <print_format_to_buf_arg+0x394>
2000072c:	eaffffa7 	b	200005d0 <print_format_to_buf_arg+0x24c>
                u32 padding = width - i;
20000730:	e04e100c 	sub	r1, lr, ip
                if ((flags & FLAG_LEFT) == 0) {
20000734:	e2155002 	ands	r5, r5, #2
                u32 padding = width - i;
20000738:	01a0e001 	moveq	lr, r1
                if ((flags & FLAG_LEFT) == 0) {
2000073c:	0a0000b4 	beq	20000a14 <print_format_to_buf_arg+0x690>
20000740:	e1a0e00c 	mov	lr, ip
20000744:	eaffffd9 	b	200006b0 <print_format_to_buf_arg+0x32c>
            char pad_char = (flags & FLAG_ZERO) ? '0' : ' ';
20000748:	e3150004 	tst	r5, #4
2000074c:	13a03030 	movne	r3, #48	; 0x30
20000750:	03a03020 	moveq	r3, #32
20000754:	e58d302c 	str	r3, [sp, #44]	; 0x2c
            i32 num = (i32)va_arg(arg, int);
20000758:	e1a03002 	mov	r3, r2
2000075c:	e4936004 	ldr	r6, [r3], #4
20000760:	e58d3014 	str	r3, [sp, #20]
            u8 lowercase = (flags & FLAG_LOWERCASE) ? FLAG_LOWERCASE : 0;
20000764:	e2053020 	and	r3, r5, #32
20000768:	e1a02003 	mov	r2, r3
            if (num < 0 && (flags & FLAG_SIGN)) {
2000076c:	e3560000 	cmp	r6, #0
20000770:	ba00003b 	blt	20000864 <print_format_to_buf_arg+0x4e0>
                sign = '+';
20000774:	e3150010 	tst	r5, #16
20000778:	03a03000 	moveq	r3, #0
2000077c:	13a0302b 	movne	r3, #43	; 0x2b
20000780:	e58d3008 	str	r3, [sp, #8]
                sign = ' ';
20000784:	e3150008 	tst	r5, #8
20000788:	e59d3008 	ldr	r3, [sp, #8]
2000078c:	13a03020 	movne	r3, #32
20000790:	e58d3008 	str	r3, [sp, #8]
            u32 num_pos = (u32)num;
20000794:	e1a03006 	mov	r3, r6
20000798:	e28d8034 	add	r8, sp, #52	; 0x34
            u32 index = 0;
2000079c:	e3a06000 	mov	r6, #0
200007a0:	e58d4018 	str	r4, [sp, #24]
200007a4:	e58d701c 	str	r7, [sp, #28]
200007a8:	e1a04003 	mov	r4, r3
200007ac:	e58d9020 	str	r9, [sp, #32]
200007b0:	e1a07002 	mov	r7, r2
200007b4:	e58d5024 	str	r5, [sp, #36]	; 0x24
200007b8:	e58da028 	str	sl, [sp, #40]	; 0x28
200007bc:	e59d900c 	ldr	r9, [sp, #12]
200007c0:	e59da010 	ldr	sl, [sp, #16]
                num_buf[index++] = number_lookup[num_pos % base] | lowercase;
200007c4:	e2866001 	add	r6, r6, #1
200007c8:	e1a0100b 	mov	r1, fp
200007cc:	e1a00004 	mov	r0, r4
200007d0:	e12fff39 	blx	r9
200007d4:	e59d3000 	ldr	r3, [sp]
200007d8:	e7d33001 	ldrb	r3, [r3, r1]
200007dc:	e1873003 	orr	r3, r7, r3
200007e0:	e4c83001 	strb	r3, [r8], #1
                num_pos /= base;
200007e4:	e1a05004 	mov	r5, r4
200007e8:	e1a0100b 	mov	r1, fp
200007ec:	e1a00004 	mov	r0, r4
200007f0:	e12fff3a 	blx	sl
200007f4:	e1a04000 	mov	r4, r0
            } while(num_pos);
200007f8:	e15b0005 	cmp	fp, r5
200007fc:	9afffff0 	bls	200007c4 <print_format_to_buf_arg+0x440>
20000800:	e59d4018 	ldr	r4, [sp, #24]
20000804:	e59d701c 	ldr	r7, [sp, #28]
20000808:	e59d9020 	ldr	r9, [sp, #32]
2000080c:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
20000810:	e59da028 	ldr	sl, [sp, #40]	; 0x28
            if (flags & FLAG_PREFIX) {
20000814:	e2152001 	ands	r2, r5, #1
            u8 sign_prefix_pad = 0;
20000818:	03a03000 	moveq	r3, #0
            if (flags & FLAG_PREFIX) {
2000081c:	0a000003 	beq	20000830 <print_format_to_buf_arg+0x4ac>
                    sign_prefix_pad += 2;
20000820:	e35b0002 	cmp	fp, #2
20000824:	135b0010 	cmpne	fp, #16
20000828:	13a03000 	movne	r3, #0
2000082c:	03a03002 	moveq	r3, #2
            if (sign) {
20000830:	e59d1008 	ldr	r1, [sp, #8]
20000834:	e3510000 	cmp	r1, #0
20000838:	0a00004b 	beq	2000096c <print_format_to_buf_arg+0x5e8>
            if (width >= 0) {
2000083c:	e3570000 	cmp	r7, #0
            u32 padding = 0;
20000840:	b3a01000 	movlt	r1, #0
            if (width >= 0) {
20000844:	ba000053 	blt	20000998 <print_format_to_buf_arg+0x614>
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
20000848:	e2830001 	add	r0, r3, #1
2000084c:	e1a01007 	mov	r1, r7
20000850:	e0803006 	add	r3, r0, r6
20000854:	e1530007 	cmp	r3, r7
20000858:	83a01000 	movhi	r1, #0
2000085c:	8a00004d 	bhi	20000998 <print_format_to_buf_arg+0x614>
20000860:	ea00004a 	b	20000990 <print_format_to_buf_arg+0x60c>
            if (num < 0 && (flags & FLAG_SIGN)) {
20000864:	e3150040 	tst	r5, #64	; 0x40
20000868:	0affffc1 	beq	20000774 <print_format_to_buf_arg+0x3f0>
                num = -num;
2000086c:	e2666000 	rsb	r6, r6, #0
                sign = '-';
20000870:	e3a0302d 	mov	r3, #45	; 0x2d
20000874:	e58d3008 	str	r3, [sp, #8]
20000878:	eaffffc1 	b	20000784 <print_format_to_buf_arg+0x400>
    if (*buf < end) {
2000087c:	e159000a 	cmp	r9, sl
20000880:	9a00004e 	bls	200009c0 <print_format_to_buf_arg+0x63c>
        *(*buf)++ = c;
20000884:	e1a0300a 	mov	r3, sl
20000888:	e3a02030 	mov	r2, #48	; 0x30
2000088c:	e4c32001 	strb	r2, [r3], #1
    if (*buf < end) {
20000890:	e1590003 	cmp	r9, r3
20000894:	9a00000e 	bls	200008d4 <print_format_to_buf_arg+0x550>
        *(*buf)++ = c;
20000898:	e3a03078 	mov	r3, #120	; 0x78
2000089c:	e5ca3001 	strb	r3, [sl, #1]
200008a0:	e28aa002 	add	sl, sl, #2
200008a4:	ea000045 	b	200009c0 <print_format_to_buf_arg+0x63c>
    if (*buf < end) {
200008a8:	e159000a 	cmp	r9, sl
200008ac:	9a000043 	bls	200009c0 <print_format_to_buf_arg+0x63c>
        *(*buf)++ = c;
200008b0:	e1a0300a 	mov	r3, sl
200008b4:	e3a02030 	mov	r2, #48	; 0x30
200008b8:	e4c32001 	strb	r2, [r3], #1
    if (*buf < end) {
200008bc:	e1590003 	cmp	r9, r3
200008c0:	9a000005 	bls	200008dc <print_format_to_buf_arg+0x558>
        *(*buf)++ = c;
200008c4:	e3a03062 	mov	r3, #98	; 0x62
200008c8:	e5ca3001 	strb	r3, [sl, #1]
200008cc:	e28aa002 	add	sl, sl, #2
200008d0:	ea00003a 	b	200009c0 <print_format_to_buf_arg+0x63c>
200008d4:	e1a0a003 	mov	sl, r3
200008d8:	ea000038 	b	200009c0 <print_format_to_buf_arg+0x63c>
200008dc:	e1a0a003 	mov	sl, r3
200008e0:	ea000036 	b	200009c0 <print_format_to_buf_arg+0x63c>
                while (padding--) {
200008e4:	e2413001 	sub	r3, r1, #1
200008e8:	e3510000 	cmp	r1, #0
200008ec:	0a00001c 	beq	20000964 <print_format_to_buf_arg+0x5e0>
200008f0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    if (*buf < end) {
200008f4:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200008f8:	84ca2001 	strbhi	r2, [sl], #1
                while (padding--) {
200008fc:	e2433001 	sub	r3, r3, #1
20000900:	e3730001 	cmn	r3, #1
20000904:	1afffffa 	bne	200008f4 <print_format_to_buf_arg+0x570>
20000908:	e1a01003 	mov	r1, r3
            while (index) {
2000090c:	e3560000 	cmp	r6, #0
20000910:	1a00002e 	bne	200009d0 <print_format_to_buf_arg+0x64c>
20000914:	ea000038 	b	200009fc <print_format_to_buf_arg+0x678>
                while (padding--) {
20000918:	e2413001 	sub	r3, r1, #1
2000091c:	e3510000 	cmp	r1, #0
20000920:	0a000035 	beq	200009fc <print_format_to_buf_arg+0x678>
20000924:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    if (*buf < end) {
20000928:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
2000092c:	84ca2001 	strbhi	r2, [sl], #1
                while (padding--) {
20000930:	e2433001 	sub	r3, r3, #1
20000934:	e3730001 	cmn	r3, #1
20000938:	1afffffa 	bne	20000928 <print_format_to_buf_arg+0x5a4>
2000093c:	ea00002e 	b	200009fc <print_format_to_buf_arg+0x678>
20000940:	e1a0b009 	mov	fp, r9
            str--;
        }
    }
    return buf + len - end;
20000944:	e59d3004 	ldr	r3, [sp, #4]
20000948:	e08a0003 	add	r0, sl, r3
2000094c:	e040000b 	sub	r0, r0, fp
}
20000950:	e28dd05c 	add	sp, sp, #92	; 0x5c
20000954:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                for (i = 0; (i < width) && ptr[i]; i++);
20000958:	e1a0c00e 	mov	ip, lr
                    while (padding--) {
2000095c:	e3e01000 	mvn	r1, #0
20000960:	ea000034 	b	20000a38 <print_format_to_buf_arg+0x6b4>
                while (padding--) {
20000964:	e1a01003 	mov	r1, r3
20000968:	eaffffe7 	b	2000090c <print_format_to_buf_arg+0x588>
            if (width >= 0) {
2000096c:	e3570000 	cmp	r7, #0
            u32 padding = 0;
20000970:	b3a01000 	movlt	r1, #0
            if (width >= 0) {
20000974:	ba00000b 	blt	200009a8 <print_format_to_buf_arg+0x624>
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
20000978:	e1a00003 	mov	r0, r3
2000097c:	e1a01007 	mov	r1, r7
20000980:	e0863003 	add	r3, r6, r3
20000984:	e1530007 	cmp	r3, r7
20000988:	83a01000 	movhi	r1, #0
2000098c:	8a000005 	bhi	200009a8 <print_format_to_buf_arg+0x624>
                    width - index - sign_prefix_pad;
20000990:	e0411006 	sub	r1, r1, r6
                padding = ((index + sign_prefix_pad) > width) ? 0 : 
20000994:	e0411000 	sub	r1, r1, r0
    if (*buf < end) {
20000998:	e59d3008 	ldr	r3, [sp, #8]
2000099c:	e3530000 	cmp	r3, #0
200009a0:	1159000a 	cmpne	r9, sl
        *(*buf)++ = c;
200009a4:	84ca3001 	strbhi	r3, [sl], #1
            if (flags & FLAG_PREFIX) {
200009a8:	e3520000 	cmp	r2, #0
200009ac:	0a000003 	beq	200009c0 <print_format_to_buf_arg+0x63c>
                if (base == 16) {
200009b0:	e35b0010 	cmp	fp, #16
200009b4:	0affffb0 	beq	2000087c <print_format_to_buf_arg+0x4f8>
                } else if (base == 2) {
200009b8:	e35b0002 	cmp	fp, #2
200009bc:	0affffb9 	beq	200008a8 <print_format_to_buf_arg+0x524>
            if ((flags & FLAG_LEFT) == 0) {
200009c0:	e2155002 	ands	r5, r5, #2
200009c4:	0affffc6 	beq	200008e4 <print_format_to_buf_arg+0x560>
            while (index) {
200009c8:	e3560000 	cmp	r6, #0
200009cc:	0affffd1 	beq	20000918 <print_format_to_buf_arg+0x594>
200009d0:	e28d3034 	add	r3, sp, #52	; 0x34
200009d4:	e0833006 	add	r3, r3, r6
    if (*buf < end) {
200009d8:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
200009dc:	85532001 	ldrbhi	r2, [r3, #-1]
200009e0:	84ca2001 	strbhi	r2, [sl], #1
            while (index) {
200009e4:	e2433001 	sub	r3, r3, #1
200009e8:	e28d2034 	add	r2, sp, #52	; 0x34
200009ec:	e1520003 	cmp	r2, r3
200009f0:	1afffff8 	bne	200009d8 <print_format_to_buf_arg+0x654>
            if (flags & FLAG_LEFT) {
200009f4:	e3550000 	cmp	r5, #0
200009f8:	1affffc6 	bne	20000918 <print_format_to_buf_arg+0x594>
            i32 num = (i32)va_arg(arg, int);
200009fc:	e59d2014 	ldr	r2, [sp, #20]
20000a00:	eafffef2 	b	200005d0 <print_format_to_buf_arg+0x24c>
                if ((flags & FLAG_LEFT) == 0) {
20000a04:	e2155002 	ands	r5, r5, #2
                u32 padding = width - i;
20000a08:	11a01007 	movne	r1, r7
                if ((flags & FLAG_LEFT) == 0) {
20000a0c:	1affff34 	bne	200006e4 <print_format_to_buf_arg+0x360>
                for (i = 0; (i < width) && ptr[i]; i++);
20000a10:	e1a0c00e 	mov	ip, lr
                    while (padding--) {
20000a14:	e24e1001 	sub	r1, lr, #1
20000a18:	e35e0000 	cmp	lr, #0
20000a1c:	0a000005 	beq	20000a38 <print_format_to_buf_arg+0x6b4>
    if (*buf < end) {
20000a20:	e159000a 	cmp	r9, sl
        *(*buf)++ = c;
20000a24:	83a03020 	movhi	r3, #32
20000a28:	84ca3001 	strbhi	r3, [sl], #1
                    while (padding--) {
20000a2c:	e2411001 	sub	r1, r1, #1
20000a30:	e3710001 	cmn	r1, #1
20000a34:	1afffff9 	bne	20000a20 <print_format_to_buf_arg+0x69c>
                while (i--) {
20000a38:	e24c3001 	sub	r3, ip, #1
20000a3c:	e35c0000 	cmp	ip, #0
20000a40:	1affff1d 	bne	200006bc <print_format_to_buf_arg+0x338>
20000a44:	eafffee1 	b	200005d0 <print_format_to_buf_arg+0x24c>

20000a48 <main>:
#include <chaos/nic.h>
#include <chaos/cache.h>
#include <chaos/timer.h>
#include <chaos/boot.h>

void main() {
20000a48:	e92d4010 	push	{r4, lr}

    kprint("\n\nStarting chaos kernel v1.0\n");
20000a4c:	e3010554 	movw	r0, #5460	; 0x1554
20000a50:	e3420000 	movt	r0, #8192	; 0x2000
20000a54:	e3003a7c 	movw	r3, #2684	; 0xa7c
20000a58:	e3423000 	movt	r3, #8192	; 0x2000
20000a5c:	e12fff33 	blx	r3
    boot_start_timer();
20000a60:	e3003b18 	movw	r3, #2840	; 0xb18
20000a64:	e3423000 	movt	r3, #8192	; 0x2000
20000a68:	e12fff33 	blx	r3
    network_start();
20000a6c:	e3003cc8 	movw	r3, #3272	; 0xcc8
20000a70:	e3423000 	movt	r3, #8192	; 0x2000
20000a74:	e12fff33 	blx	r3

    while (1);
20000a78:	eafffffe 	b	20000a78 <main+0x30>

20000a7c <kprint>:

#define KPRINT_BUF_SIZE 1024

static char kprint_buf[KPRINT_BUF_SIZE];

void kprint(const char* message, ...) {
20000a7c:	e92d000f 	push	{r0, r1, r2, r3}
20000a80:	e92d4030 	push	{r4, r5, lr}
20000a84:	e24dd00c 	sub	sp, sp, #12
    va_list arg;
    va_start(arg, message);
20000a88:	e28d301c 	add	r3, sp, #28
20000a8c:	e58d3004 	str	r3, [sp, #4]
    u32 count = print_format_to_buf_arg(kprint_buf, KPRINT_BUF_SIZE, message, arg);
20000a90:	e3014bc0 	movw	r4, #7104	; 0x1bc0
20000a94:	e3424000 	movt	r4, #8192	; 0x2000
20000a98:	e59d2018 	ldr	r2, [sp, #24]
20000a9c:	e3a01b01 	mov	r1, #1024	; 0x400
20000aa0:	e1a00004 	mov	r0, r4
20000aa4:	e3005384 	movw	r5, #900	; 0x384
20000aa8:	e3425000 	movt	r5, #8192	; 0x2000
20000aac:	e12fff35 	blx	r5
20000ab0:	e1a01000 	mov	r1, r0
    va_end(arg);

    kprint_from_buf(kprint_buf, count);
20000ab4:	e1a00004 	mov	r0, r4
20000ab8:	e3003d08 	movw	r3, #3336	; 0xd08
20000abc:	e3423000 	movt	r3, #8192	; 0x2000
20000ac0:	e12fff33 	blx	r3
}
20000ac4:	e28dd00c 	add	sp, sp, #12
20000ac8:	e8bd4030 	pop	{r4, r5, lr}
20000acc:	e28dd010 	add	sp, sp, #16
20000ad0:	e12fff1e 	bx	lr

20000ad4 <panic>:
// Kernel panic implementation

#include <chaos/panic.h>
#include <chaos/kprint.h>

void panic(const char* message) {
20000ad4:	e92d4010 	push	{r4, lr}
20000ad8:	e1a01000 	mov	r1, r0
    kprint("Kernel panic!\n\t{s}\n", message);
20000adc:	e3010574 	movw	r0, #5492	; 0x1574
20000ae0:	e3420000 	movt	r0, #8192	; 0x2000
20000ae4:	e3003a7c 	movw	r3, #2684	; 0xa7c
20000ae8:	e3423000 	movt	r3, #8192	; 0x2000
20000aec:	e12fff33 	blx	r3
    while (1);
20000af0:	eafffffe 	b	20000af0 <panic+0x1c>

20000af4 <assert_handler>:
// Kernel assert implementation

#include <chaos/assert.h>
#include <chaos/kprint.h>

void assert_handler(const char* file, u32 line) {
20000af4:	e92d4010 	push	{r4, lr}
20000af8:	e1a02001 	mov	r2, r1
    kprint("Kernel assert!\n\t{s}: {d}\n", file, line);
20000afc:	e1a01000 	mov	r1, r0
20000b00:	e3010588 	movw	r0, #5512	; 0x1588
20000b04:	e3420000 	movt	r0, #8192	; 0x2000
20000b08:	e3003a7c 	movw	r3, #2684	; 0xa7c
20000b0c:	e3423000 	movt	r3, #8192	; 0x2000
20000b10:	e12fff33 	blx	r3
    while (1);
20000b14:	eafffffe 	b	20000b14 <assert_handler+0x20>

20000b18 <boot_start_timer>:

#define BOOT_BUF_SIZE 1024

static char boot_message_buf[BOOT_BUF_SIZE];

void boot_start_timer() {
20000b18:	e92d4010 	push	{r4, lr}
    const struct timer_iface* timer = get_timer();
20000b1c:	e3013528 	movw	r3, #5416	; 0x1528
20000b20:	e3423000 	movt	r3, #8192	; 0x2000
20000b24:	e12fff33 	blx	r3
    if (!timer) {
20000b28:	e2504000 	subs	r4, r0, #0
20000b2c:	0a000008 	beq	20000b54 <boot_start_timer+0x3c>
        panic("Wrong");
    }

    if (timer->init) {
20000b30:	e5943000 	ldr	r3, [r4]
20000b34:	e3530000 	cmp	r3, #0
20000b38:	0a000000 	beq	20000b40 <boot_start_timer+0x28>
        timer->init();
20000b3c:	e12fff33 	blx	r3
    }

    if (timer->restart) {
20000b40:	e5943004 	ldr	r3, [r4, #4]
20000b44:	e3530000 	cmp	r3, #0
20000b48:	08bd8010 	popeq	{r4, pc}
        timer->restart();
20000b4c:	e12fff33 	blx	r3
    }
}
20000b50:	e8bd8010 	pop	{r4, pc}
        panic("Wrong");
20000b54:	e30105a4 	movw	r0, #5540	; 0x15a4
20000b58:	e3420000 	movt	r0, #8192	; 0x2000
20000b5c:	e3003ad4 	movw	r3, #2772	; 0xad4
20000b60:	e3423000 	movt	r3, #8192	; 0x2000
20000b64:	e12fff33 	blx	r3
20000b68:	eafffff0 	b	20000b30 <boot_start_timer+0x18>

20000b6c <boot_message>:

void boot_message(const char* message, ...) {
20000b6c:	e92d000f 	push	{r0, r1, r2, r3}
20000b70:	e92d4030 	push	{r4, r5, lr}
20000b74:	e24dd00c 	sub	sp, sp, #12
    // Log the timestamp
    const struct timer_iface* timer = get_timer();
20000b78:	e3013528 	movw	r3, #5416	; 0x1528
20000b7c:	e3423000 	movt	r3, #8192	; 0x2000
20000b80:	e12fff33 	blx	r3
    if (timer) {
20000b84:	e3500000 	cmp	r0, #0
20000b88:	0a00000e 	beq	20000bc8 <boot_message+0x5c>
        if (timer->get_time) {
20000b8c:	e5903008 	ldr	r3, [r0, #8]
20000b90:	e3530000 	cmp	r3, #0
20000b94:	0a00000b 	beq	20000bc8 <boot_message+0x5c>
            u32 time = timer->get_time();
20000b98:	e12fff33 	blx	r3
            kprint("[{3:d}.{0:3:d}] ", time / 1000, time % 1000);
20000b9c:	e3041dd3 	movw	r1, #19923	; 0x4dd3
20000ba0:	e3411062 	movt	r1, #4194	; 0x1062
20000ba4:	e0813091 	umull	r3, r1, r1, r0
20000ba8:	e1a01321 	lsr	r1, r1, #6
20000bac:	e3a02ffa 	mov	r2, #1000	; 0x3e8
20000bb0:	e0620192 	mls	r2, r2, r1, r0
20000bb4:	e30105ac 	movw	r0, #5548	; 0x15ac
20000bb8:	e3420000 	movt	r0, #8192	; 0x2000
20000bbc:	e3003a7c 	movw	r3, #2684	; 0xa7c
20000bc0:	e3423000 	movt	r3, #8192	; 0x2000
20000bc4:	e12fff33 	blx	r3
        }
    }
    
    va_list arg;
    va_start(arg, message);
20000bc8:	e28d301c 	add	r3, sp, #28
20000bcc:	e58d3004 	str	r3, [sp, #4]
    u32 count = print_format_to_buf_arg(boot_message_buf, BOOT_BUF_SIZE, message, arg);
20000bd0:	e3014fc0 	movw	r4, #8128	; 0x1fc0
20000bd4:	e3424000 	movt	r4, #8192	; 0x2000
20000bd8:	e59d2018 	ldr	r2, [sp, #24]
20000bdc:	e3a01b01 	mov	r1, #1024	; 0x400
20000be0:	e1a00004 	mov	r0, r4
20000be4:	e3005384 	movw	r5, #900	; 0x384
20000be8:	e3425000 	movt	r5, #8192	; 0x2000
20000bec:	e12fff35 	blx	r5
20000bf0:	e1a01000 	mov	r1, r0
    va_end(arg);

    kprint_from_buf(boot_message_buf, count);
20000bf4:	e1a00004 	mov	r0, r4
20000bf8:	e3003d08 	movw	r3, #3336	; 0xd08
20000bfc:	e3423000 	movt	r3, #8192	; 0x2000
20000c00:	e12fff33 	blx	r3
}
20000c04:	e28dd00c 	add	sp, sp, #12
20000c08:	e8bd4030 	pop	{r4, r5, lr}
20000c0c:	e28dd010 	add	sp, sp, #16
20000c10:	e12fff1e 	bx	lr

20000c14 <netbuf_init>:
#define list_get_struct(node, type, member) \
    (type *)((u8 *)node - offsetof(type, member))

// Initializes a list
static inline void list_init(struct list_node* list) {
    list->prev = list;
20000c14:	e30413c0 	movw	r1, #17344	; 0x43c0
20000c18:	e3421006 	movt	r1, #8198	; 0x2006
20000c1c:	e5811004 	str	r1, [r1, #4]
// Initializes the netbuffers
void netbuf_init() {
    // Initialize the netbuffer pool
    list_init(&netbuf_pool);

    for (u32 i = 0; i < NIC_MAX_BUF; i++) {
20000c20:	e59f3038 	ldr	r3, [pc, #56]	; 20000c60 <netbuf_init+0x4c>
20000c24:	e283ca62 	add	ip, r3, #401408	; 0x62000
static inline void __list_add(struct list_node* new, struct list_node* prev,
    struct list_node* next) {
    prev->next = new;
    next->prev = new;
    new->next = next;
    new->prev = prev;
20000c28:	e1a00001 	mov	r0, r1
        list_push_front(&buffers[i].node, &netbuf_pool);
20000c2c:	e1a02001 	mov	r2, r1
20000c30:	e1a01003 	mov	r1, r3
    next->prev = new;
20000c34:	e5823004 	str	r3, [r2, #4]
    new->next = next;
20000c38:	e5832000 	str	r2, [r3]
    new->prev = prev;
20000c3c:	e5830004 	str	r0, [r3, #4]
    for (u32 i = 0; i < NIC_MAX_BUF; i++) {
20000c40:	e2833e62 	add	r3, r3, #1568	; 0x620
20000c44:	e153000c 	cmp	r3, ip
20000c48:	1afffff7 	bne	20000c2c <netbuf_init+0x18>
20000c4c:	e30433c0 	movw	r3, #17344	; 0x43c0
20000c50:	e3423006 	movt	r3, #8198	; 0x2006
20000c54:	e59f2008 	ldr	r2, [pc, #8]	; 20000c64 <netbuf_init+0x50>
20000c58:	e5832000 	str	r2, [r3]
    }
}
20000c5c:	e12fff1e 	bx	lr
20000c60:	200029d0 	.word	0x200029d0
20000c64:	200643b0 	.word	0x200643b0

20000c68 <alloc_netbuf>:
    node->prev = NULL;
}

// Deletes the first node in the list
static inline struct list_node* list_pop_front(struct list_node* list) {
    if (list->next == list) {
20000c68:	e30433c0 	movw	r3, #17344	; 0x43c0
20000c6c:	e3423006 	movt	r3, #8198	; 0x2006
20000c70:	e5930000 	ldr	r0, [r3]
20000c74:	e1500003 	cmp	r0, r3
20000c78:	0a000008 	beq	20000ca0 <alloc_netbuf+0x38>
    __list_delete(node->prev, node->next);
20000c7c:	e5902004 	ldr	r2, [r0, #4]
20000c80:	e5903000 	ldr	r3, [r0]
    prev->next = next;
20000c84:	e5823000 	str	r3, [r2]
    next->prev = prev;
20000c88:	e5832004 	str	r2, [r3, #4]
    node->next = NULL;
20000c8c:	e3a03000 	mov	r3, #0
20000c90:	e5803000 	str	r3, [r0]
    node->prev = NULL;
20000c94:	e5803004 	str	r3, [r0, #4]
    struct list_node* node = list_pop_front(&netbuf_pool);
    assert(node);

    // Convert the list node to a netbuf and return it
    return list_get_struct(node, struct netbuf, node);
}
20000c98:	e2400e61 	sub	r0, r0, #1552	; 0x610
20000c9c:	e12fff1e 	bx	lr
struct netbuf* alloc_netbuf() {
20000ca0:	e92d4010 	push	{r4, lr}
    assert(node);
20000ca4:	e3a0101b 	mov	r1, #27
20000ca8:	e30105c0 	movw	r0, #5568	; 0x15c0
20000cac:	e3420000 	movt	r0, #8192	; 0x2000
20000cb0:	e3003af4 	movw	r3, #2804	; 0xaf4
20000cb4:	e3423000 	movt	r3, #8192	; 0x2000
20000cb8:	e12fff33 	blx	r3
20000cbc:	e3a00000 	mov	r0, #0
}
20000cc0:	e2400e61 	sub	r0, r0, #1552	; 0x610
20000cc4:	e8bd8010 	pop	{r4, pc}

20000cc8 <network_start>:
#include <chaos/netbuf.h>
#include <chaos/kprint.h>
#include <chaos/nic.h>
#include <chaos/kprint.h>

void network_start() {
20000cc8:	e92d4010 	push	{r4, lr}
    boot_message("Starting networking\n");
20000ccc:	e30105f0 	movw	r0, #5616	; 0x15f0
20000cd0:	e3420000 	movt	r0, #8192	; 0x2000
20000cd4:	e3004b6c 	movw	r4, #2924	; 0xb6c
20000cd8:	e3424000 	movt	r4, #8192	; 0x2000
20000cdc:	e12fff34 	blx	r4
    
    netbuf_init();
20000ce0:	e3003c14 	movw	r3, #3092	; 0xc14
20000ce4:	e3423000 	movt	r3, #8192	; 0x2000
20000ce8:	e12fff33 	blx	r3
    nic_init();
20000cec:	e30133c0 	movw	r3, #5056	; 0x13c0
20000cf0:	e3423000 	movt	r3, #8192	; 0x2000
20000cf4:	e12fff33 	blx	r3

    boot_message("Networking ready\n");
20000cf8:	e3010608 	movw	r0, #5640	; 0x1608
20000cfc:	e3420000 	movt	r0, #8192	; 0x2000
20000d00:	e12fff34 	blx	r4
}
20000d04:	e8bd8010 	pop	{r4, pc}

20000d08 <kprint_from_buf>:
#include <sama5d2/regmap.h>

void kprint_from_buf(const char* buf, u32 size) {
    struct uart_reg* const hw = UART1_REG;

    while (size--) {
20000d08:	e3510000 	cmp	r1, #0
20000d0c:	012fff1e 	bxeq	lr
void kprint_from_buf(const char* buf, u32 size) {
20000d10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
20000d14:	e241c001 	sub	ip, r1, #1
20000d18:	e2401001 	sub	r1, r0, #1
20000d1c:	e080c00c 	add	ip, r0, ip
        // Make sure we terminatie the line with CR-LF
        if (*buf == '\n') {
            while (!(hw->sr & (1 << 1)));
20000d20:	e3a02000 	mov	r2, #0
20000d24:	e34f2802 	movt	r2, #63490	; 0xf802
            hw->thr = '\r';
20000d28:	e3a0e00d 	mov	lr, #13
20000d2c:	ea000006 	b	20000d4c <kprint_from_buf+0x44>
        }
        while (!(hw->sr & (1 << 1)));
20000d30:	e5923014 	ldr	r3, [r2, #20]
20000d34:	e3130002 	tst	r3, #2
20000d38:	0afffffc 	beq	20000d30 <kprint_from_buf+0x28>
        hw->thr = *buf++;
20000d3c:	e5d03000 	ldrb	r3, [r0]
20000d40:	e582301c 	str	r3, [r2, #28]
    while (size--) {
20000d44:	e151000c 	cmp	r1, ip
20000d48:	049df004 	popeq	{pc}		; (ldreq pc, [sp], #4)
        if (*buf == '\n') {
20000d4c:	e2811001 	add	r1, r1, #1
20000d50:	e1a00001 	mov	r0, r1
20000d54:	e5d13000 	ldrb	r3, [r1]
20000d58:	e353000a 	cmp	r3, #10
20000d5c:	1afffff3 	bne	20000d30 <kprint_from_buf+0x28>
            while (!(hw->sr & (1 << 1)));
20000d60:	e5923014 	ldr	r3, [r2, #20]
20000d64:	e3130002 	tst	r3, #2
20000d68:	0afffffc 	beq	20000d60 <kprint_from_buf+0x58>
            hw->thr = '\r';
20000d6c:	e582e01c 	str	lr, [r2, #28]
20000d70:	eaffffee 	b	20000d30 <kprint_from_buf+0x28>

20000d74 <sama5d2_gpio_set_func>:
#include <sama5d2/sama5d2_gpio.h>
#include <chaos/assert.h>

// Sets the IO controller functions. This will determine which peripheral will override 
// and control the pin
void sama5d2_gpio_set_func(struct gpio_reg* hw, u32 pin, enum gpio_func func) {
20000d74:	e92d4070 	push	{r4, r5, r6, lr}
20000d78:	e1a04000 	mov	r4, r0
20000d7c:	e1a05001 	mov	r5, r1
20000d80:	e1a06002 	mov	r6, r2
    assert(pin < 32);
20000d84:	e351001f 	cmp	r1, #31
20000d88:	8a000004 	bhi	20000da0 <sama5d2_gpio_set_func+0x2c>

    hw->mskr = (1 << pin);
20000d8c:	e3a01001 	mov	r1, #1
20000d90:	e1a05511 	lsl	r5, r1, r5
20000d94:	e5845000 	str	r5, [r4]
    hw->cfgr = func;
20000d98:	e5846004 	str	r6, [r4, #4]
}
20000d9c:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(pin < 32);
20000da0:	e3a01009 	mov	r1, #9
20000da4:	e301061c 	movw	r0, #5660	; 0x161c
20000da8:	e3420000 	movt	r0, #8192	; 0x2000
20000dac:	e3003af4 	movw	r3, #2804	; 0xaf4
20000db0:	e3423000 	movt	r3, #8192	; 0x2000
20000db4:	e12fff33 	blx	r3
20000db8:	eafffff3 	b	20000d8c <sama5d2_gpio_set_func+0x18>

20000dbc <sama5d2_per_clk_en>:
#include <chaos/assert.h>

// These functions takes in PID numbers defined in the Periheral chapter in the datasheet
// (SAMA5D2 datasheet page 57)

void sama5d2_per_clk_en(u32 pid) {
20000dbc:	e92d4010 	push	{r4, lr}
20000dc0:	e1a04000 	mov	r4, r0
    assert(pid >= 2 && pid < 64);
20000dc4:	e2403002 	sub	r3, r0, #2
20000dc8:	e353003d 	cmp	r3, #61	; 0x3d
20000dcc:	8a000007 	bhi	20000df0 <sama5d2_per_clk_en+0x34>

    // Get a pointer to the hardware
    struct pmc_reg* hw = PMC_REG;

    if (pid < 32) {
20000dd0:	e354001f 	cmp	r4, #31
20000dd4:	8a00000c 	bhi	20000e0c <sama5d2_per_clk_en+0x50>
        hw->pcer0 = (1 << pid);
20000dd8:	e3a00001 	mov	r0, #1
20000ddc:	e1a04410 	lsl	r4, r0, r4
20000de0:	e3a03901 	mov	r3, #16384	; 0x4000
20000de4:	e34f3001 	movt	r3, #61441	; 0xf001
20000de8:	e5834010 	str	r4, [r3, #16]
20000dec:	e8bd8010 	pop	{r4, pc}
    assert(pid >= 2 && pid < 64);
20000df0:	e3a0100b 	mov	r1, #11
20000df4:	e3010650 	movw	r0, #5712	; 0x1650
20000df8:	e3420000 	movt	r0, #8192	; 0x2000
20000dfc:	e3003af4 	movw	r3, #2804	; 0xaf4
20000e00:	e3423000 	movt	r3, #8192	; 0x2000
20000e04:	e12fff33 	blx	r3
20000e08:	eafffff0 	b	20000dd0 <sama5d2_per_clk_en+0x14>
    } else {
        pid -= 32;
20000e0c:	e2444020 	sub	r4, r4, #32
        hw->pcer1 = (1 << pid);
20000e10:	e3a00001 	mov	r0, #1
20000e14:	e1a04410 	lsl	r4, r0, r4
20000e18:	e3a03901 	mov	r3, #16384	; 0x4000
20000e1c:	e34f3001 	movt	r3, #61441	; 0xf001
20000e20:	e5834100 	str	r4, [r3, #256]	; 0x100
    }
}
20000e24:	e8bd8010 	pop	{r4, pc}

20000e28 <sama5d2_genricc_clk_en>:
        pid -= 32;
        hw->pcdr1 = (1 << pid);
    }
}

void sama5d2_genricc_clk_en(u32 pid, u8 div, enum gck_clk_source src) {
20000e28:	e92d4070 	push	{r4, r5, r6, lr}
20000e2c:	e1a05000 	mov	r5, r0
20000e30:	e1a04001 	mov	r4, r1
20000e34:	e1a06002 	mov	r6, r2
    assert(pid >= 2 && pid < 64);
20000e38:	e2403002 	sub	r3, r0, #2
20000e3c:	e353003d 	cmp	r3, #61	; 0x3d
20000e40:	8a000010 	bhi	20000e88 <sama5d2_genricc_clk_en+0x60>
    assert(div != 0);
20000e44:	e3540000 	cmp	r4, #0
20000e48:	0a000015 	beq	20000ea4 <sama5d2_genricc_clk_en+0x7c>

    // Get the hardware
    struct pmc_reg* hw = PMC_REG;

    // Enable read operation
    hw->pcr = pid;
20000e4c:	e3a0c901 	mov	ip, #16384	; 0x4000
20000e50:	e34fc001 	movt	ip, #61441	; 0xf001
20000e54:	e58c510c 	str	r5, [ip, #268]	; 0x10c
    u32 reg = hw->pcr;
20000e58:	e59c210c 	ldr	r2, [ip, #268]	; 0x10c
    reg &= ~((0xFF << 20) | (0x07 << 8) | 0x7F);

    // Set the division
    reg |= ((div - 1) << 20);
20000e5c:	e2444001 	sub	r4, r4, #1
    reg &= ~((0xFF << 20) | (0x07 << 8) | 0x7F);
20000e60:	e30f3880 	movw	r3, #63616	; 0xf880
20000e64:	e34f300f 	movt	r3, #61455	; 0xf00f
20000e68:	e0033002 	and	r3, r3, r2
20000e6c:	e1833a04 	orr	r3, r3, r4, lsl #20
20000e70:	e1833005 	orr	r3, r3, r5

    // Set the clock source
    reg |= (src << 8);

    // Select the peripheral
    reg |= pid;
20000e74:	e1833406 	orr	r3, r3, r6, lsl #8

    // Enable clock
    reg |= (1 << 29);

    // Write operation
    reg |= (1 << 12);
20000e78:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
20000e7c:	e3833a01 	orr	r3, r3, #4096	; 0x1000

    // Configure the generic clock
    hw->pcr = reg;
20000e80:	e58c310c 	str	r3, [ip, #268]	; 0x10c
}
20000e84:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(pid >= 2 && pid < 64);
20000e88:	e3a01027 	mov	r1, #39	; 0x27
20000e8c:	e3010650 	movw	r0, #5712	; 0x1650
20000e90:	e3420000 	movt	r0, #8192	; 0x2000
20000e94:	e3003af4 	movw	r3, #2804	; 0xaf4
20000e98:	e3423000 	movt	r3, #8192	; 0x2000
20000e9c:	e12fff33 	blx	r3
20000ea0:	eaffffe7 	b	20000e44 <sama5d2_genricc_clk_en+0x1c>
    assert(div != 0);
20000ea4:	e3a01028 	mov	r1, #40	; 0x28
20000ea8:	e3010650 	movw	r0, #5712	; 0x1650
20000eac:	e3420000 	movt	r0, #8192	; 0x2000
20000eb0:	e3003af4 	movw	r3, #2804	; 0xaf4
20000eb4:	e3423000 	movt	r3, #8192	; 0x2000
20000eb8:	e12fff33 	blx	r3
20000ebc:	eaffffe2 	b	20000e4c <sama5d2_genricc_clk_en+0x24>

20000ec0 <nic_setup_dma_queues>:
};

// Configures all the NIC queues (rings). This will allocate a netbuf for each DMA 
// descriptor and link the DMA descriptor to the netbuf->buf. This also configures the 
// hardware registers for each queue
void nic_setup_dma_queues() {
20000ec0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
20000ec4:	e24dd01c 	sub	sp, sp, #28
    for (u32 i = 0; i < NIC_QUEUES; i++) {
20000ec8:	e3013724 	movw	r3, #5924	; 0x1724
20000ecc:	e3423000 	movt	r3, #8192	; 0x2000
20000ed0:	e58d3008 	str	r3, [sp, #8]
        const struct netbuf* netbuf;
        const struct nic_queue* queue = &queues[i];

        // Configure the TX queue
        for (u32 j = 0; j < queue->tx_count; j++) {
            netbuf = alloc_netbuf();
20000ed4:	e3009c68 	movw	r9, #3176	; 0xc68
20000ed8:	e3429000 	movt	r9, #8192	; 0x2000
            struct nic_tx_desc* tx = &queue->tx[j];

            // Link the descriptor to the netbuf
            // TODO: when the MMU is on we must convert to physical address
            tx->addr = (u32)netbuf;
            tx->status_word = 0;
20000edc:	e3a0a000 	mov	sl, #0
            netbuf = alloc_netbuf();
            struct nic_rx_desc* rx = &queue->rx[j];

            // Link the descriptor to the netbuf
            // TODO: when the MMU is on we must convert to physical address
            assert(((u32)netbuf & 0b11) == 0);
20000ee0:	e3003af4 	movw	r3, #2804	; 0xaf4
20000ee4:	e3423000 	movt	r3, #8192	; 0x2000
20000ee8:	e58d300c 	str	r3, [sp, #12]
20000eec:	e3013684 	movw	r3, #5764	; 0x1684
20000ef0:	e3423000 	movt	r3, #8192	; 0x2000
20000ef4:	e58d3010 	str	r3, [sp, #16]
20000ef8:	ea000027 	b	20000f9c <nic_setup_dma_queues+0xdc>
20000efc:	e3a010b9 	mov	r1, #185	; 0xb9
20000f00:	e59d0010 	ldr	r0, [sp, #16]
20000f04:	e59d300c 	ldr	r3, [sp, #12]
20000f08:	e12fff33 	blx	r3

            rx->addr_word = 0;
            rx->status_word = 0;
20000f0c:	e58ba004 	str	sl, [fp, #4]

            // The address is in bits 32..2
            rx->addr = (u32)netbuf >> 2;
20000f10:	e1a04124 	lsr	r4, r4, #2
20000f14:	e1a0300a 	mov	r3, sl
20000f18:	e7df3114 	bfi	r3, r4, #2, #30
20000f1c:	e7873006 	str	r3, [r7, r6]
        for (u32 j = 0; j < queue->rx_count; j++) {
20000f20:	e2855001 	add	r5, r5, #1
20000f24:	e59d3004 	ldr	r3, [sp, #4]
20000f28:	e1550003 	cmp	r5, r3
20000f2c:	0a000007 	beq	20000f50 <nic_setup_dma_queues+0x90>
            netbuf = alloc_netbuf();
20000f30:	e12fff39 	blx	r9
20000f34:	e1a04000 	mov	r4, r0
            struct nic_rx_desc* rx = &queue->rx[j];
20000f38:	e1a06185 	lsl	r6, r5, #3
20000f3c:	e5987000 	ldr	r7, [r8]
20000f40:	e087b006 	add	fp, r7, r6
            assert(((u32)netbuf & 0b11) == 0);
20000f44:	e3100003 	tst	r0, #3
20000f48:	0affffef 	beq	20000f0c <nic_setup_dma_queues+0x4c>
20000f4c:	eaffffea 	b	20000efc <nic_setup_dma_queues+0x3c>
        }

        // Mark the end descriptor with the wrap bit, causing the DMA to fetch the base
        // descriptor on the next read
        queue->rx[queue->rx_count - 1].wrap = 1;
20000f50:	e59d3004 	ldr	r3, [sp, #4]
20000f54:	e243321e 	sub	r3, r3, #-536870911	; 0xe0000001
20000f58:	e5981000 	ldr	r1, [r8]
20000f5c:	e7d12183 	ldrb	r2, [r1, r3, lsl #3]
20000f60:	e3822002 	orr	r2, r2, #2
20000f64:	e7c12183 	strb	r2, [r1, r3, lsl #3]
        queue->tx[queue->tx_count - 1].wrap = 1;
20000f68:	e59d3014 	ldr	r3, [sp, #20]
20000f6c:	e243221e 	sub	r2, r3, #-536870911	; 0xe0000001
20000f70:	e5983004 	ldr	r3, [r8, #4]
20000f74:	e0833182 	add	r3, r3, r2, lsl #3
20000f78:	e5d32007 	ldrb	r2, [r3, #7]
20000f7c:	e3822040 	orr	r2, r2, #64	; 0x40
20000f80:	e5c32007 	strb	r2, [r3, #7]
    for (u32 i = 0; i < NIC_QUEUES; i++) {
20000f84:	e59d3008 	ldr	r3, [sp, #8]
20000f88:	e2833010 	add	r3, r3, #16
20000f8c:	e58d3008 	str	r3, [sp, #8]
20000f90:	e59f20f0 	ldr	r2, [pc, #240]	; 20001088 <nic_setup_dma_queues+0x1c8>
20000f94:	e1530002 	cmp	r3, r2
20000f98:	0a000017 	beq	20000ffc <nic_setup_dma_queues+0x13c>
        for (u32 j = 0; j < queue->tx_count; j++) {
20000f9c:	e59d3008 	ldr	r3, [sp, #8]
20000fa0:	e1a08003 	mov	r8, r3
20000fa4:	e5933008 	ldr	r3, [r3, #8]
20000fa8:	e58d3014 	str	r3, [sp, #20]
20000fac:	e3530000 	cmp	r3, #0
20000fb0:	13a04000 	movne	r4, #0
20000fb4:	159d5014 	ldrne	r5, [sp, #20]
20000fb8:	0a000009 	beq	20000fe4 <nic_setup_dma_queues+0x124>
            netbuf = alloc_netbuf();
20000fbc:	e12fff39 	blx	r9
            struct nic_tx_desc* tx = &queue->tx[j];
20000fc0:	e5982004 	ldr	r2, [r8, #4]
20000fc4:	e0823184 	add	r3, r2, r4, lsl #3
            tx->addr = (u32)netbuf;
20000fc8:	e7820184 	str	r0, [r2, r4, lsl #3]
            tx->status_word = 0;
20000fcc:	e583a004 	str	sl, [r3, #4]
            tx->used = 1;
20000fd0:	e3a02080 	mov	r2, #128	; 0x80
20000fd4:	e5c32007 	strb	r2, [r3, #7]
        for (u32 j = 0; j < queue->tx_count; j++) {
20000fd8:	e2844001 	add	r4, r4, #1
20000fdc:	e1540005 	cmp	r4, r5
20000fe0:	1afffff5 	bne	20000fbc <nic_setup_dma_queues+0xfc>
        for (u32 j = 0; j < queue->rx_count; j++) {
20000fe4:	e598300c 	ldr	r3, [r8, #12]
20000fe8:	e58d3004 	str	r3, [sp, #4]
20000fec:	e3530000 	cmp	r3, #0
20000ff0:	0affffd6 	beq	20000f50 <nic_setup_dma_queues+0x90>
20000ff4:	e3a05000 	mov	r5, #0
20000ff8:	eaffffcc 	b	20000f30 <nic_setup_dma_queues+0x70>
    }

    // Map in the queues in the NIC hardware
    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->rbqb       = (u32)rx_descs;
20000ffc:	e30423d0 	movw	r2, #17360	; 0x43d0
20001000:	e3422006 	movt	r2, #8198	; 0x2006
20001004:	e3a03902 	mov	r3, #32768	; 0x8000
20001008:	e34f3800 	movt	r3, #63488	; 0xf800
2000100c:	e5832018 	str	r2, [r3, #24]
    nic_reg->tbqb       = (u32)tx_descs;
20001010:	e3042508 	movw	r2, #17672	; 0x4508
20001014:	e3422006 	movt	r2, #8198	; 0x2006
20001018:	e583201c 	str	r2, [r3, #28]
    nic_reg->rbqbapq[0] = (u32)rx_descs_q1;
2000101c:	e30424d0 	movw	r2, #17616	; 0x44d0
20001020:	e3422006 	movt	r2, #8198	; 0x2006
20001024:	e583247c 	str	r2, [r3, #1148]	; 0x47c
    nic_reg->tbqbapq[0] = (u32)tx_descs_q1;
20001028:	e3042608 	movw	r2, #17928	; 0x4608
2000102c:	e3422006 	movt	r2, #8198	; 0x2006
20001030:	e583243c 	str	r2, [r3, #1084]	; 0x43c
    nic_reg->rbqbapq[1] = (u32)rx_descs_q2;
20001034:	e30424e0 	movw	r2, #17632	; 0x44e0
20001038:	e3422006 	movt	r2, #8198	; 0x2006
2000103c:	e5832480 	str	r2, [r3, #1152]	; 0x480
    nic_reg->tbqbapq[1] = (u32)tx_descs_q2;
20001040:	e3042618 	movw	r2, #17944	; 0x4618
20001044:	e3422006 	movt	r2, #8198	; 0x2006
20001048:	e5832440 	str	r2, [r3, #1088]	; 0x440
    nic_reg->rbqbapq[2] = (u32)rx_descs_q3;
2000104c:	e30424f0 	movw	r2, #17648	; 0x44f0
20001050:	e3422006 	movt	r2, #8198	; 0x2006
20001054:	e5832484 	str	r2, [r3, #1156]	; 0x484
    nic_reg->tbqbapq[2] = (u32)tx_descs_q3;
20001058:	e3042628 	movw	r2, #17960	; 0x4628
2000105c:	e3422006 	movt	r2, #8198	; 0x2006
20001060:	e5832444 	str	r2, [r3, #1092]	; 0x444

    // Make sure we start reading from the base descriptor
    rx_index = 0;
20001064:	e3043500 	movw	r3, #17664	; 0x4500
20001068:	e3423006 	movt	r3, #8198	; 0x2006
2000106c:	e3a02000 	mov	r2, #0
20001070:	e5832000 	str	r2, [r3]
    tx_index = 0;
20001074:	e3043638 	movw	r3, #17976	; 0x4638
20001078:	e3423006 	movt	r3, #8198	; 0x2006
2000107c:	e5832000 	str	r2, [r3]
}
20001080:	e28dd01c 	add	sp, sp, #28
20001084:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
20001088:	20001764 	.word	0x20001764

2000108c <ethernet_phy_read>:

// Reads a 16-bit register from the addressed ethernet PHY. Both the register address and 
// the etnernet PHY address should be in range 0..31
u16 ethernet_phy_read(u8 phy, u8 reg) {
2000108c:	e92d4070 	push	{r4, r5, r6, lr}
20001090:	e1a05000 	mov	r5, r0
20001094:	e1a04001 	mov	r4, r1
    assert(phy < 32);
20001098:	e350001f 	cmp	r0, #31
2000109c:	8a000012 	bhi	200010ec <ethernet_phy_read+0x60>
    assert(reg < 32);
200010a0:	e354001f 	cmp	r4, #31
200010a4:	8a000017 	bhi	20001108 <ethernet_phy_read+0x7c>
    
    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->man = (1 << 30) | (1 << 29) | (1 << 17) | (phy << 23) | (reg << 18);
200010a8:	e1a03904 	lsl	r3, r4, #18
200010ac:	e1833b85 	orr	r3, r3, r5, lsl #23
200010b0:	e3833206 	orr	r3, r3, #1610612736	; 0x60000000
200010b4:	e3833802 	orr	r3, r3, #131072	; 0x20000
200010b8:	e3a02902 	mov	r2, #32768	; 0x8000
200010bc:	e34f2800 	movt	r2, #63488	; 0xf800
200010c0:	e5823034 	str	r3, [r2, #52]	; 0x34
    while ((nic_reg->nsr & (1 << 2)) == 0);
200010c4:	e3a02902 	mov	r2, #32768	; 0x8000
200010c8:	e34f2800 	movt	r2, #63488	; 0xf800
200010cc:	e5923008 	ldr	r3, [r2, #8]
200010d0:	e3130004 	tst	r3, #4
200010d4:	0afffffc 	beq	200010cc <ethernet_phy_read+0x40>

    return (u16)nic_reg->man;
200010d8:	e3a03902 	mov	r3, #32768	; 0x8000
200010dc:	e34f3800 	movt	r3, #63488	; 0xf800
200010e0:	e5930034 	ldr	r0, [r3, #52]	; 0x34
}
200010e4:	e6ff0070 	uxth	r0, r0
200010e8:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(phy < 32);
200010ec:	e3a010dc 	mov	r1, #220	; 0xdc
200010f0:	e3010684 	movw	r0, #5764	; 0x1684
200010f4:	e3420000 	movt	r0, #8192	; 0x2000
200010f8:	e3003af4 	movw	r3, #2804	; 0xaf4
200010fc:	e3423000 	movt	r3, #8192	; 0x2000
20001100:	e12fff33 	blx	r3
20001104:	eaffffe5 	b	200010a0 <ethernet_phy_read+0x14>
    assert(reg < 32);
20001108:	e3a010dd 	mov	r1, #221	; 0xdd
2000110c:	e3010684 	movw	r0, #5764	; 0x1684
20001110:	e3420000 	movt	r0, #8192	; 0x2000
20001114:	e3003af4 	movw	r3, #2804	; 0xaf4
20001118:	e3423000 	movt	r3, #8192	; 0x2000
2000111c:	e12fff33 	blx	r3
20001120:	eaffffe0 	b	200010a8 <ethernet_phy_read+0x1c>

20001124 <ethernet_phy_write>:

// Writes a 16-bit register to the address ethernet PHY. Both the register address and 
// the etnernet PHY address should be in range 0..31
void ethernet_phy_write(u8 phy, u8 reg, u16 val) {
20001124:	e92d4070 	push	{r4, r5, r6, lr}
20001128:	e1a06000 	mov	r6, r0
2000112c:	e1a05001 	mov	r5, r1
20001130:	e1a04002 	mov	r4, r2
    assert(phy < 32);
20001134:	e350001f 	cmp	r0, #31
20001138:	8a00000e 	bhi	20001178 <ethernet_phy_write+0x54>
    assert(reg < 32);
2000113c:	e355001f 	cmp	r5, #31
20001140:	8a000013 	bhi	20001194 <ethernet_phy_write+0x70>

    struct nic_reg* const nic_reg = NIC_REG;

    nic_reg->man = (1 << 30) | (1 << 28) | (1 << 17) | (phy << 23) | (reg << 18) | val;
20001144:	e1843b86 	orr	r3, r4, r6, lsl #23
20001148:	e1833905 	orr	r3, r3, r5, lsl #18
2000114c:	e3833205 	orr	r3, r3, #1342177280	; 0x50000000
20001150:	e3833802 	orr	r3, r3, #131072	; 0x20000
20001154:	e3a02902 	mov	r2, #32768	; 0x8000
20001158:	e34f2800 	movt	r2, #63488	; 0xf800
2000115c:	e5823034 	str	r3, [r2, #52]	; 0x34
    while ((nic_reg->nsr & (1 << 2)) == 0);
20001160:	e3a02902 	mov	r2, #32768	; 0x8000
20001164:	e34f2800 	movt	r2, #63488	; 0xf800
20001168:	e5923008 	ldr	r3, [r2, #8]
2000116c:	e3130004 	tst	r3, #4
20001170:	0afffffc 	beq	20001168 <ethernet_phy_write+0x44>
20001174:	e8bd8070 	pop	{r4, r5, r6, pc}
    assert(phy < 32);
20001178:	e3a010ea 	mov	r1, #234	; 0xea
2000117c:	e3010684 	movw	r0, #5764	; 0x1684
20001180:	e3420000 	movt	r0, #8192	; 0x2000
20001184:	e3003af4 	movw	r3, #2804	; 0xaf4
20001188:	e3423000 	movt	r3, #8192	; 0x2000
2000118c:	e12fff33 	blx	r3
20001190:	eaffffe9 	b	2000113c <ethernet_phy_write+0x18>
    assert(reg < 32);
20001194:	e3a010eb 	mov	r1, #235	; 0xeb
20001198:	e3010684 	movw	r0, #5764	; 0x1684
2000119c:	e3420000 	movt	r0, #8192	; 0x2000
200011a0:	e3003af4 	movw	r3, #2804	; 0xaf4
200011a4:	e3423000 	movt	r3, #8192	; 0x2000
200011a8:	e12fff33 	blx	r3
200011ac:	eaffffe4 	b	20001144 <ethernet_phy_write+0x20>

200011b0 <ethernet_phy_scan>:
}

// Performs a scan after available ethernet PHYs and return the address of the first 
// responding PHY
u8 ethernet_phy_scan() {
200011b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    for (u32 i = 0; i < 32; i++) {
200011b4:	e3a04000 	mov	r4, #0

        // Read the PHY ID reg
        if (ethernet_phy_read(i, 2) != 0xFFFF) {
200011b8:	e3a08002 	mov	r8, #2
200011bc:	e301608c 	movw	r6, #4236	; 0x108c
200011c0:	e3426000 	movt	r6, #8192	; 0x2000
200011c4:	e30f7fff 	movw	r7, #65535	; 0xffff
200011c8:	e6ef5074 	uxtb	r5, r4
200011cc:	e1a01008 	mov	r1, r8
200011d0:	e1a00005 	mov	r0, r5
200011d4:	e12fff36 	blx	r6
200011d8:	e1500007 	cmp	r0, r7
200011dc:	1a000008 	bne	20001204 <ethernet_phy_scan+0x54>
    for (u32 i = 0; i < 32; i++) {
200011e0:	e2844001 	add	r4, r4, #1
200011e4:	e3540020 	cmp	r4, #32
200011e8:	1afffff6 	bne	200011c8 <ethernet_phy_scan+0x18>
            return i;
        }
    }
    panic("No phy\n");
200011ec:	e30106b8 	movw	r0, #5816	; 0x16b8
200011f0:	e3420000 	movt	r0, #8192	; 0x2000
200011f4:	e3003ad4 	movw	r3, #2772	; 0xad4
200011f8:	e3423000 	movt	r3, #8192	; 0x2000
200011fc:	e12fff33 	blx	r3
    return 0;
20001200:	e3a05000 	mov	r5, #0
}
20001204:	e1a00005 	mov	r0, r5
20001208:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

2000120c <phy_establish_link>:

// Configures the ethernet PHY for full-duplex, 100 Mbps opration and returns when the 
// auto-negotiation is complete and the link is up 
void phy_establish_link(u8 addr) {
2000120c:	e92d4070 	push	{r4, r5, r6, lr}
20001210:	e1a04000 	mov	r4, r0
    // Check if the link is already up
    if ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0) {
20001214:	e3a01001 	mov	r1, #1
20001218:	e301308c 	movw	r3, #4236	; 0x108c
2000121c:	e3423000 	movt	r3, #8192	; 0x2000
20001220:	e12fff33 	blx	r3
20001224:	e3100020 	tst	r0, #32
20001228:	0a000008 	beq	20001250 <phy_establish_link+0x44>
        ethernet_phy_write(addr, 0, ethernet_phy_read(addr, 0) | (1 << 9));
        while ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0);
    }

    // Wait for the link-up status
    while ((ethernet_phy_read(addr, 1) & (1 << 2)) == 0);
2000122c:	e3a06001 	mov	r6, #1
20001230:	e301508c 	movw	r5, #4236	; 0x108c
20001234:	e3425000 	movt	r5, #8192	; 0x2000
20001238:	e1a01006 	mov	r1, r6
2000123c:	e1a00004 	mov	r0, r4
20001240:	e12fff35 	blx	r5
20001244:	e3100004 	tst	r0, #4
20001248:	0afffffa 	beq	20001238 <phy_establish_link+0x2c>
2000124c:	e8bd8070 	pop	{r4, r5, r6, pc}
        ethernet_phy_write(addr, 4, ethernet_phy_read(addr, 4) | (0b1111 << 5));
20001250:	e3a01004 	mov	r1, #4
20001254:	e1a00004 	mov	r0, r4
20001258:	e301608c 	movw	r6, #4236	; 0x108c
2000125c:	e3426000 	movt	r6, #8192	; 0x2000
20001260:	e12fff36 	blx	r6
20001264:	e3802e1e 	orr	r2, r0, #480	; 0x1e0
20001268:	e6ff2072 	uxth	r2, r2
2000126c:	e3a01004 	mov	r1, #4
20001270:	e1a00004 	mov	r0, r4
20001274:	e3015124 	movw	r5, #4388	; 0x1124
20001278:	e3425000 	movt	r5, #8192	; 0x2000
2000127c:	e12fff35 	blx	r5
        ethernet_phy_write(addr, 0, ethernet_phy_read(addr, 0) | (1 << 9));
20001280:	e3a01000 	mov	r1, #0
20001284:	e1a00004 	mov	r0, r4
20001288:	e12fff36 	blx	r6
2000128c:	e3802c02 	orr	r2, r0, #512	; 0x200
20001290:	e6ff2072 	uxth	r2, r2
20001294:	e3a01000 	mov	r1, #0
20001298:	e1a00004 	mov	r0, r4
2000129c:	e12fff35 	blx	r5
        while ((ethernet_phy_read(addr, 1) & (1 << 5)) == 0);
200012a0:	e3a06001 	mov	r6, #1
200012a4:	e301508c 	movw	r5, #4236	; 0x108c
200012a8:	e3425000 	movt	r5, #8192	; 0x2000
200012ac:	e1a01006 	mov	r1, r6
200012b0:	e1a00004 	mov	r0, r4
200012b4:	e12fff35 	blx	r5
200012b8:	e3100020 	tst	r0, #32
200012bc:	0afffffa 	beq	200012ac <phy_establish_link+0xa0>
200012c0:	eaffffd9 	b	2000122c <phy_establish_link+0x20>

200012c4 <get_phy_settings>:
}

// Get the speed and duplex setting from the link partner
void get_phy_settings(u8 addr, struct nic_link_setting* link_setting) {
200012c4:	e92d4010 	push	{r4, lr}
200012c8:	e1a04001 	mov	r4, r1
    // Read the link partner status register
    u16 reg = ethernet_phy_read(addr, 5);
200012cc:	e3a01005 	mov	r1, #5
200012d0:	e301308c 	movw	r3, #4236	; 0x108c
200012d4:	e3423000 	movt	r3, #8192	; 0x2000
200012d8:	e12fff33 	blx	r3

    if (reg & (0b11 << 7)) {
200012dc:	e3100d06 	tst	r0, #384	; 0x180
        link_setting->speed = NIC_100Mbps;
200012e0:	13a03000 	movne	r3, #0
200012e4:	15c43000 	strbne	r3, [r4]
        link_setting->duplex = (reg & (1 << 8)) ? NIC_DUPLEX_FULL : NIC_DUPLEX_HALF;
200012e8:	12200c01 	eorne	r0, r0, #256	; 0x100
200012ec:	17e00450 	ubfxne	r0, r0, #8, #1
    } else {
        link_setting->speed = NIC_10Mbps;
200012f0:	03a03001 	moveq	r3, #1
200012f4:	05c43000 	strbeq	r3, [r4]
        link_setting->duplex = (reg & (1 << 6)) ? NIC_DUPLEX_FULL : NIC_DUPLEX_HALF;
200012f8:	02200040 	eoreq	r0, r0, #64	; 0x40
200012fc:	07e00350 	ubfxeq	r0, r0, #6, #1
20001300:	e5c40001 	strb	r0, [r4, #1]
    }
}
20001304:	e8bd8010 	pop	{r4, pc}

20001308 <nic_pin_init>:

// Configure the NIC pins
void nic_pin_init() {
20001308:	e92d4070 	push	{r4, r5, r6, lr}
    sama5d2_gpio_set_func(GPIOD_REG,  9, GPIO_FUNC_D);
2000130c:	e30850c0 	movw	r5, #32960	; 0x80c0
20001310:	e34f5c03 	movt	r5, #64515	; 0xfc03
20001314:	e3a02004 	mov	r2, #4
20001318:	e3a01009 	mov	r1, #9
2000131c:	e1a00005 	mov	r0, r5
20001320:	e3004d74 	movw	r4, #3444	; 0xd74
20001324:	e3424000 	movt	r4, #8192	; 0x2000
20001328:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 10, GPIO_FUNC_D);
2000132c:	e3a02004 	mov	r2, #4
20001330:	e3a0100a 	mov	r1, #10
20001334:	e1a00005 	mov	r0, r5
20001338:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 11, GPIO_FUNC_D);
2000133c:	e3a02004 	mov	r2, #4
20001340:	e3a0100b 	mov	r1, #11
20001344:	e1a00005 	mov	r0, r5
20001348:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 12, GPIO_FUNC_D);
2000134c:	e3a02004 	mov	r2, #4
20001350:	e3a0100c 	mov	r1, #12
20001354:	e1a00005 	mov	r0, r5
20001358:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 13, GPIO_FUNC_D);
2000135c:	e3a02004 	mov	r2, #4
20001360:	e3a0100d 	mov	r1, #13
20001364:	e1a00005 	mov	r0, r5
20001368:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 14, GPIO_FUNC_D);
2000136c:	e3a02004 	mov	r2, #4
20001370:	e3a0100e 	mov	r1, #14
20001374:	e1a00005 	mov	r0, r5
20001378:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 15, GPIO_FUNC_D);
2000137c:	e3a02004 	mov	r2, #4
20001380:	e3a0100f 	mov	r1, #15
20001384:	e1a00005 	mov	r0, r5
20001388:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 16, GPIO_FUNC_D);
2000138c:	e3a02004 	mov	r2, #4
20001390:	e3a01010 	mov	r1, #16
20001394:	e1a00005 	mov	r0, r5
20001398:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 17, GPIO_FUNC_D);
2000139c:	e3a02004 	mov	r2, #4
200013a0:	e3a01011 	mov	r1, #17
200013a4:	e1a00005 	mov	r0, r5
200013a8:	e12fff34 	blx	r4
    sama5d2_gpio_set_func(GPIOD_REG, 18, GPIO_FUNC_D);
200013ac:	e3a02004 	mov	r2, #4
200013b0:	e3a01012 	mov	r1, #18
200013b4:	e1a00005 	mov	r0, r5
200013b8:	e12fff34 	blx	r4
}
200013bc:	e8bd8070 	pop	{r4, r5, r6, pc}

200013c0 <nic_init>:
    }
}

// Configures the NIC hardware and enables the NIC interface. This will setup the NIC in
// a non-interrupt driven mode. Polling is the only way of sending / receiving packets
void nic_init() {
200013c0:	e92d4070 	push	{r4, r5, r6, lr}
200013c4:	e24dd008 	sub	sp, sp, #8
    boot_message("Starting kernel NIC driver for SAMA5D2\n");
200013c8:	e30106fc 	movw	r0, #5884	; 0x16fc
200013cc:	e3420000 	movt	r0, #8192	; 0x2000
200013d0:	e3003b6c 	movw	r3, #2924	; 0xb6c
200013d4:	e3423000 	movt	r3, #8192	; 0x2000
200013d8:	e12fff33 	blx	r3

    // Enable clock and pins
    sama5d2_per_clk_en(5);
200013dc:	e3a00005 	mov	r0, #5
200013e0:	e3003dbc 	movw	r3, #3516	; 0xdbc
200013e4:	e3423000 	movt	r3, #8192	; 0x2000
200013e8:	e12fff33 	blx	r3
    nic_pin_init();
200013ec:	e3013308 	movw	r3, #4872	; 0x1308
200013f0:	e3423000 	movt	r3, #8192	; 0x2000
200013f4:	e12fff33 	blx	r3

    // Reset the interface
    struct nic_reg* const nic_reg = NIC_REG;
    nic_reg->ncr = 0;
200013f8:	e3a04902 	mov	r4, #32768	; 0x8000
200013fc:	e34f4800 	movt	r4, #63488	; 0xf800
20001400:	e3a03000 	mov	r3, #0
20001404:	e5843000 	str	r3, [r4]
    nic_reg->ncfgr = 0;
20001408:	e5843004 	str	r3, [r4, #4]

    // Disable interrupts
    nic_reg->idr = ~0;
2000140c:	e3e05000 	mvn	r5, #0
20001410:	e584502c 	str	r5, [r4, #44]	; 0x2c
    nic_reg->idrpq[0] = ~0;
20001414:	e584561c 	str	r5, [r4, #1564]	; 0x61c
    nic_reg->idrpq[1] = ~0;
20001418:	e5845620 	str	r5, [r4, #1568]	; 0x620

    // Clear interrupts
    (void)nic_reg->isr;
2000141c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
    (void)nic_reg->isrpq[0];
20001420:	e59433fc 	ldr	r3, [r4, #1020]	; 0x3fc
    (void)nic_reg->isrpq[1];
20001424:	e5943400 	ldr	r3, [r4, #1024]	; 0x400

    //Setup the DMA queues
    nic_setup_dma_queues();
20001428:	e3003ec0 	movw	r3, #3776	; 0xec0
2000142c:	e3423000 	movt	r3, #8192	; 0x2000
20001430:	e12fff33 	blx	r3
    
    // Enable the PHY management interface and set the bus speed
    nic_reg->ncr |= (1 << 4);
20001434:	e5943000 	ldr	r3, [r4]
20001438:	e3833010 	orr	r3, r3, #16
2000143c:	e5843000 	str	r3, [r4]
    nic_reg->ncfgr = (nic_reg->ncfgr & ~(0x7 << 18)) | (5 << 18);
20001440:	e5943004 	ldr	r3, [r4, #4]
20001444:	e3c33707 	bic	r3, r3, #1835008	; 0x1c0000
20001448:	e3833705 	orr	r3, r3, #1310720	; 0x140000
2000144c:	e5843004 	str	r3, [r4, #4]
    
    // Wait for the link-up status
    phy_addr = ethernet_phy_scan();
20001450:	e30131b0 	movw	r3, #4528	; 0x11b0
20001454:	e3423000 	movt	r3, #8192	; 0x2000
20001458:	e12fff33 	blx	r3
2000145c:	e30463c8 	movw	r6, #17352	; 0x43c8
20001460:	e3426006 	movt	r6, #8198	; 0x2006
20001464:	e5c60000 	strb	r0, [r6]
    phy_establish_link(phy_addr);
20001468:	e301320c 	movw	r3, #4620	; 0x120c
2000146c:	e3423000 	movt	r3, #8192	; 0x2000
20001470:	e12fff33 	blx	r3

    // Get the highest link setting
    struct nic_link_setting link_setting;
    get_phy_settings(phy_addr, &link_setting);
20001474:	e28d1004 	add	r1, sp, #4
20001478:	e5d60000 	ldrb	r0, [r6]
2000147c:	e30132c4 	movw	r3, #4804	; 0x12c4
20001480:	e3423000 	movt	r3, #8192	; 0x2000
20001484:	e12fff33 	blx	r3

    // Copy all frames, 100Mbps and full-duplex configuration
    nic_reg->ncfgr = (1 << 0) | (1 << 1) | (1 << 4);
20001488:	e3a03013 	mov	r3, #19
2000148c:	e5843004 	str	r3, [r4, #4]

    // Configure for RMII mode
    nic_reg->ur = (1 << 0);
20001490:	e3a03001 	mov	r3, #1
20001494:	e584300c 	str	r3, [r4, #12]

    // DMA configuration
    nic_reg->dcfgr = (4 << 0) | (3 << 8) | (1 << 10) | (0x18 << 16);
20001498:	e3003704 	movw	r3, #1796	; 0x704
2000149c:	e3403018 	movt	r3, #24
200014a0:	e5843010 	str	r3, [r4, #16]

    // Ignore interrupts
    nic_reg->idr = 0xFFFFFFFF;
200014a4:	e584502c 	str	r5, [r4, #44]	; 0x2c

    // Enable receiver and transmitter
    nic_reg->ncr |= (1 << 2) | (1 << 3);
200014a8:	e5943000 	ldr	r3, [r4]
200014ac:	e383300c 	orr	r3, r3, #12
200014b0:	e5843000 	str	r3, [r4]
}
200014b4:	e28dd008 	add	sp, sp, #8
200014b8:	e8bd8070 	pop	{r4, r5, r6, pc}

200014bc <sama5d2_restart>:

void sama5d2_restart() {
    struct timer_reg* const timer_reg = TIMER0_REG;

    // Call in the software trigger
    timer_reg->channel[0].ccr = (1 << 2) | (1 << 0);
200014bc:	e3a03903 	mov	r3, #49152	; 0xc000
200014c0:	e34f3800 	movt	r3, #63488	; 0xf800
200014c4:	e3a02005 	mov	r2, #5
200014c8:	e5832000 	str	r2, [r3]
}
200014cc:	e12fff1e 	bx	lr

200014d0 <sama5d2_get_time>:

u32 sama5d2_get_time() {
    struct timer_reg* const timer_reg = TIMER0_REG;
    return timer_reg->channel[0].cv;
200014d0:	e3a03903 	mov	r3, #49152	; 0xc000
200014d4:	e34f3800 	movt	r3, #63488	; 0xf800
200014d8:	e5930010 	ldr	r0, [r3, #16]
}
200014dc:	e12fff1e 	bx	lr

200014e0 <sama5d2_init>:
void sama5d2_init() {
200014e0:	e92d4010 	push	{r4, lr}
    sama5d2_per_clk_en(35);
200014e4:	e3a00023 	mov	r0, #35	; 0x23
200014e8:	e3003dbc 	movw	r3, #3516	; 0xdbc
200014ec:	e3423000 	movt	r3, #8192	; 0x2000
200014f0:	e12fff33 	blx	r3
    sama5d2_genricc_clk_en(35, 32, GCK_CLK_SLOW);
200014f4:	e3a02000 	mov	r2, #0
200014f8:	e3a01020 	mov	r1, #32
200014fc:	e3a00023 	mov	r0, #35	; 0x23
20001500:	e3003e28 	movw	r3, #3624	; 0xe28
20001504:	e3423000 	movt	r3, #8192	; 0x2000
20001508:	e12fff33 	blx	r3
    timer_reg->channel[0].ccr = (1 << 1);
2000150c:	e3a03903 	mov	r3, #49152	; 0xc000
20001510:	e34f3800 	movt	r3, #63488	; 0xf800
20001514:	e3a02002 	mov	r2, #2
20001518:	e5832000 	str	r2, [r3]
    timer_reg->channel[0].cmr = 0;
2000151c:	e3a02000 	mov	r2, #0
20001520:	e5832004 	str	r2, [r3, #4]
}
20001524:	e8bd8010 	pop	{r4, pc}

20001528 <get_timer>:
    .get_time = sama5d2_get_time
};

const struct timer_iface* get_timer() {
    return &sama5d2_timer_iface;
}
20001528:	e3010764 	movw	r0, #5988	; 0x1764
2000152c:	e3420000 	movt	r0, #8192	; 0x2000
20001530:	e12fff1e 	bx	lr

Disassembly of section .init:

20001534 <_init>:
20001534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20001536:	bf00      	nop

Disassembly of section .fini:

20001538 <_fini>:
20001538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000153a:	bf00      	nop
